<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🗑️ Garbage Collection - Interview Prep Documentation</title>
    <meta name="description" content="Comprehensive guides for JavaScript, TypeScript, and React Native interview preparation">
    
    <!-- GitHub Pages compatible styling -->
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
        }
        
        .container {
            max-width: 100%;
        }
        
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
            margin-top: 2em;
            margin-bottom: 1em;
        }
        
        h1 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        
        h2 {
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 5px;
        }
        
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
        }
        
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
        }
        
        blockquote {
            border-left: 4px solid #3498db;
            margin: 0;
            padding-left: 20px;
            color: #666;
            font-style: italic;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        
        th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .navigation {
            background-color: #2c3e50;
            color: white;
            padding: 10px 0;
            margin-bottom: 20px;
        }
        
        .navigation a {
            color: white;
            text-decoration: none;
            margin-right: 20px;
        }
        
        .navigation a:hover {
            text-decoration: underline;
        }
        
        .breadcrumb {
            margin-bottom: 20px;
            color: #666;
        }
        
        .breadcrumb a {
            color: #3498db;
            text-decoration: none;
        }
        
        .breadcrumb a:hover {
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            h2 {
                font-size: 1.4em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="navigation">
            <a href="/">Home</a>
            <a href="/Javascript/">JavaScript</a>
            <a href="/TypeScript/">TypeScript</a>
            <a href="/React-Native/">React Native</a>
        </nav>
        
        
        
        <main>
            <h1 id="️-garbage-collection">🗑️ Garbage Collection</h1>

<blockquote>
  <p><strong>Understanding how JavaScript automatically manages memory and prevents memory leaks</strong></p>
</blockquote>

<link rel="stylesheet" href="../common-styles.css" />

<hr />

<h2 id="-table-of-contents">📋 Table of Contents</h2>

<ul>
  <li><a href="#what-is-garbage-collection">What is Garbage Collection?</a></li>
  <li><a href="#memory-lifecycle">Memory Lifecycle</a></li>
  <li><a href="#garbage-collection-algorithms">Garbage Collection Algorithms</a></li>
  <li><a href="#reference-counting">Reference Counting</a></li>
  <li><a href="#mark-and-sweep">Mark and Sweep</a></li>
  <li><a href="#generational-garbage-collection">Generational Garbage Collection</a></li>
  <li><a href="#memory-leaks">Memory Leaks</a></li>
  <li><a href="#detailed-examples">Detailed Examples</a></li>
  <li><a href="#common-pitfalls">Common Pitfalls</a></li>
  <li><a href="#best-practices">Best Practices</a></li>
  <li><a href="#key-points">Key Points</a></li>
  <li><a href="#common-interview-questions">Common Interview Questions</a></li>
  <li><a href="#practice-exercises">Practice Exercises</a></li>
  <li><a href="#additional-resources">Additional Resources</a></li>
</ul>

<hr />

<h2 id="-what-is-garbage-collection">🎯 What is Garbage Collection?</h2>

<p><strong>Garbage Collection</strong> is JavaScript’s automatic memory management system that identifies and frees memory that is no longer accessible by the program. It prevents memory leaks and manages memory allocation/deallocation automatically.</p>

<h3 id="why-understanding-this-matters">Why Understanding This Matters:</h3>
<ul>
  <li><strong>Memory Management</strong>: Write memory-efficient code</li>
  <li><strong>Performance</strong>: Understand memory allocation patterns</li>
  <li><strong>Debugging</strong>: Identify and fix memory leaks</li>
  <li><strong>Application Stability</strong>: Prevent crashes from memory exhaustion</li>
  <li><strong>Scalability</strong>: Build applications that handle large datasets</li>
</ul>

<hr />

<h2 id="-memory-lifecycle">🔄 Memory Lifecycle</h2>

<p>Memory in JavaScript follows a predictable lifecycle from allocation to garbage collection.</p>

<h3 id="ascii-diagram-memory-lifecycle">ASCII Diagram: Memory Lifecycle</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MEMORY LIFECYCLE
┌─────────────────────────────────┐
│ 1. ALLOCATION                  │
│    Memory is allocated          │
│    for variables, objects, etc. │
│    ↓                           │
│ 2. USAGE                       │
│    Memory is read/written      │
│    during program execution     │
│    ↓                           │
│ 3. RELEASE                     │
│    Memory becomes unreachable   │
│    (no references remain)       │
│    ↓                           │
│ 4. GARBAGE COLLECTION          │
│    GC identifies and frees     │
│    unreachable memory          │
└─────────────────────────────────┘
</code></pre></div></div>

<hr />

<h2 id="-garbage-collection-algorithms">🧮 Garbage Collection Algorithms</h2>

<p>JavaScript engines use different algorithms to identify and collect garbage memory.</p>

<h3 id="1-reference-counting">1. <strong>Reference Counting</strong></h3>
<ul>
  <li>Counts references to each object</li>
  <li>Frees memory when reference count reaches zero</li>
  <li>Simple but can’t handle circular references</li>
</ul>

<h3 id="2-mark-and-sweep">2. <strong>Mark and Sweep</strong></h3>
<ul>
  <li>Marks all reachable objects from root</li>
  <li>Sweeps (frees) unmarked objects</li>
  <li>Handles circular references correctly</li>
  <li>Modern JavaScript engines use this</li>
</ul>

<h3 id="3-generational-collection">3. <strong>Generational Collection</strong></h3>
<ul>
  <li>Divides memory into generations</li>
  <li>Young generation (new objects) collected frequently</li>
  <li>Old generation (surviving objects) collected less often</li>
  <li>Optimizes for typical object lifecycle</li>
</ul>

<hr />

<h2 id="-reference-counting">🔢 Reference Counting</h2>

<p><strong>Reference Counting</strong> tracks how many references point to each object.</p>

<h3 id="how-it-works">How It Works:</h3>
<ol>
  <li><strong>Increment</strong> reference count when object is referenced</li>
  <li><strong>Decrement</strong> reference count when reference is removed</li>
  <li><strong>Free</strong> memory when count reaches zero</li>
</ol>

<h3 id="ascii-diagram-reference-counting">ASCII Diagram: Reference Counting</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>REFERENCE COUNTING EXAMPLE
┌─────────────────────────────────┐
│ let obj1 = { name: "John" };   │
│ let obj2 = obj1;                │
│ let obj3 = obj1;                │
│                                 │
│ obj1: { name: "John" }          │
│ Reference count: 3              │
│ (obj1, obj2, obj3 point to it) │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ obj1 = null;                    │
│ obj2 = null;                    │
│ obj3 = null;                    │
│                                 │
│ Object becomes unreachable      │
│ Reference count: 0              │
│ Memory is freed                 │
└─────────────────────────────────┘
</code></pre></div></div>

<hr />

<h2 id="-mark-and-sweep">🎯 Mark and Sweep</h2>

<p><strong>Mark and Sweep</strong> is the primary garbage collection algorithm used in modern JavaScript engines.</p>

<h3 id="how-it-works-1">How It Works:</h3>
<ol>
  <li><strong>Mark Phase</strong>: Traverse from root objects, mark all reachable objects</li>
  <li><strong>Sweep Phase</strong>: Free memory of unmarked objects</li>
  <li><strong>Compact Phase</strong>: (Optional) Move objects to reduce fragmentation</li>
</ol>

<h3 id="ascii-diagram-mark-and-sweep">ASCII Diagram: Mark and Sweep</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MARK AND SWEEP PROCESS
┌─────────────────────────────────┐
│ ROOT OBJECTS                    │
│ (Global, function scope)        │
│                                 │
│ global → objA → objB            │
│           ↓                     │
│         objC → objD             │
│                                 │
│ objE (unreachable)              │
│ objF (unreachable)              │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ MARK PHASE                     │
│ global: ✓                      │
│ objA: ✓                        │
│ objB: ✓                        │
│ objC: ✓                        │
│ objD: ✓                        │
│ objE: ✗ (unmarked)            │
│ objF: ✗ (unmarked)            │
└─────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│ SWEEP PHASE                     │
│ Free objE and objF memory      │
│ Keep marked objects             │
│                                 │
│ Result: Clean memory            │
└─────────────────────────────────┘
</code></pre></div></div>

<hr />

<h2 id="️-generational-garbage-collection">🏗️ Generational Garbage Collection</h2>

<p><strong>Generational Collection</strong> optimizes garbage collection by treating different object ages differently.</p>

<h3 id="memory-generations">Memory Generations:</h3>
<ul>
  <li><strong>Young Generation (Nursery)</strong>: Newly allocated objects</li>
  <li><strong>Old Generation</strong>: Objects that survived multiple collections</li>
  <li><strong>Large Object Space</strong>: Very large objects</li>
</ul>

<h3 id="ascii-diagram-generational-collection">ASCII Diagram: Generational Collection</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GENERATIONAL GARBAGE COLLECTION
┌─────────────────────────────────┐
│        YOUNG GENERATION         │
│      (Nursery - New Objects)    │
│  ┌─────────┐ ┌─────────┐        │
│  │ obj1    │ │ obj2    │        │
│  │ (new)   │ │ (new)   │        │
│  └─────────┘ └─────────┘        │
│                                 │
│  • Collected frequently         │
│  • Most objects die young       │
│  • Fast collection              │
└─────────────────────────────────┘
              │
              ▼
┌─────────────────────────────────┐
│        OLD GENERATION           │
│    (Surviving Objects)          │
│  ┌─────────┐ ┌─────────┐        │
│  │ obj3    │ │ obj4    │        │
│  │ (old)   │ │ (old)   │        │
│  └─────────┘ └─────────┘        │
│                                 │
│  • Collected less frequently    │
│  • Objects likely to survive    │
│  • Slower collection            │
└─────────────────────────────────┘
</code></pre></div></div>

<hr />

<h2 id="-memory-leaks">🚨 Memory Leaks</h2>

<p><strong>Memory Leaks</strong> occur when memory is allocated but never freed, causing memory usage to grow over time.</p>

<h3 id="common-causes">Common Causes:</h3>
<ol>
  <li><strong>Global Variables</strong>: Accidental global assignments</li>
  <li><strong>Closures</strong>: Holding references to large objects</li>
  <li><strong>Event Listeners</strong>: Not removing when elements are destroyed</li>
  <li><strong>Timers</strong>: <code class="language-plaintext highlighter-rouge">setInterval</code> without cleanup</li>
  <li><strong>DOM References</strong>: Holding references to removed elements</li>
</ol>

<hr />

<h2 id="-detailed-examples">💻 Detailed Examples</h2>

<h3 id="example-1-basic-memory-management">Example 1: Basic Memory Management</h3>
<div style="position: relative;">
<button onclick="copyCode(this)" style="position: absolute; top: 10px; right: 10px; background: #007acc; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px;">📋 Copy</button>



```javascript
console.log("=== BASIC MEMORY MANAGEMENT ===");

// Memory allocation
console.log("=== Memory Allocation ===");
let largeObject = {
    data: new Array(1000000).fill("some data"),
    timestamp: Date.now()
};

console.log("Large object created with 1M elements");
console.log("Memory usage should increase");

// Memory usage (approximate)
const memoryUsage = process.memoryUsage();
console.log("Memory usage:", {
    rss: Math.round(memoryUsage.rss / 1024 / 1024) + " MB",
    heapUsed: Math.round(memoryUsage.heapUsed / 1024 / 1024) + " MB",
    heapTotal: Math.round(memoryUsage.heapTotal / 1024 / 1024) + " MB"
});

// Memory release
console.log("\n=== Memory Release ===");
largeObject = null;  // Remove reference

console.log("Reference removed, object becomes unreachable");
console.log("Garbage collection can now free this memory");

// Force garbage collection (if available)
if (global.gc) {
    global.gc();
    console.log("Garbage collection triggered");
    
    const memoryAfterGC = process.memoryUsage();
    console.log("Memory after GC:", {
        rss: Math.round(memoryAfterGC.rss / 1024 / 1024) + " MB",
        heapUsed: Math.round(memoryAfterGC.heapUsed / 1024 / 1024) + " MB",
        heapTotal: Math.round(memoryAfterGC.heapTotal / 1024 / 1024) + " MB"
    });
} else {
    console.log("Run with --expose-gc flag to enable manual GC");
}

console.log("\n=== KEY INSIGHT ===");
console.log("Setting variables to null removes references");
console.log("Unreferenced objects become eligible for GC");
console.log("Memory is freed automatically by the engine");
```


</div>

<h3 id="example-2-circular-references-and-garbage-collection">Example 2: Circular References and Garbage Collection</h3>
<div style="position: relative;">
<button onclick="copyCode(this)" style="position: absolute; top: 10px; right: 10px; background: #007acc; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px;">📋 Copy</button>



```javascript
console.log("=== CIRCULAR REFERENCES AND GC ===");

// Create circular reference
console.log("=== Creating Circular Reference ===");
let objA = { name: "Object A" };
let objB = { name: "Object B" };

// Create circular reference
objA.reference = objB;
objB.reference = objA;

console.log("Circular reference created:");
console.log("objA.reference === objB:", objA.reference === objB);
console.log("objB.reference === objA:", objB.reference === objA);

// Memory usage before cleanup
const memoryBefore = process.memoryUsage();
console.log("\nMemory before cleanup:", {
    heapUsed: Math.round(memoryBefore.heapUsed / 1024 / 1024) + " MB"
});

// Remove external references
console.log("\n=== Removing External References ===");
objA = null;
objB = null;

console.log("External references removed");
console.log("Objects are now only referenced by each other");

// Check if objects are still accessible
try {
    console.log("objA:", objA);  // null
    console.log("objB:", objB);  // null
} catch (error) {
    console.log("Error accessing objects:", error.message);
}

// Force garbage collection
if (global.gc) {
    global.gc();
    console.log("\nGarbage collection triggered");
    
    const memoryAfter = process.memoryUsage();
    console.log("Memory after GC:", {
        heapUsed: Math.round(memoryAfter.heapUsed / 1024 / 1024) + " MB"
    });
    
    const memoryFreed = memoryBefore.heapUsed - memoryAfter.heapUsed;
    console.log("Memory freed:", Math.round(memoryFreed / 1024 / 1024) + " MB");
} else {
    console.log("\nRun with --expose-gc flag to see memory cleanup");
}

console.log("\n=== KEY INSIGHT ===");
console.log("Circular references don't prevent garbage collection");
console.log("Mark and Sweep algorithm handles circular references");
console.log("Objects become unreachable when no external references exist");
```


</div>

<h3 id="example-3-memory-leaks-in-event-listeners">Example 3: Memory Leaks in Event Listeners</h3>
<div style="position: relative;">
<button onclick="copyCode(this)" style="position: absolute; top: 10px; right: 10px; background: #007acc; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px;">📋 Copy</button>



```javascript
console.log("=== MEMORY LEAKS IN EVENT LISTENERS ===");

// Simulate DOM elements
console.log("=== Creating DOM-like Elements ===");
class DOMElement {
    constructor(tagName) {
        this.tagName = tagName;
        this.eventListeners = new Map();
        this.children = [];
    }
    
    addEventListener(event, callback) {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event).push(callback);
        console.log(`Added ${event} listener to ${this.tagName}`);
    }
    
    removeEventListener(event, callback) {
        if (this.eventListeners.has(event)) {
            const listeners = this.eventListeners.get(event);
            const index = listeners.indexOf(callback);
            if (index &gt; -1) {
                listeners.splice(index, 1);
                console.log(`Removed ${event} listener from ${this.tagName}`);
            }
        }
    }
    
    getEventListenersCount() {
        let total = 0;
        for (const [event, listeners] of this.eventListeners) {
            total += listeners.length;
        }
        return total;
    }
}

// Create elements
const button = new DOMElement("button");
const container = new DOMElement("div");

// Add event listeners
console.log("\n=== Adding Event Listeners ===");
const clickHandler = () =&gt; console.log("Button clicked");
const mouseHandler = () =&gt; console.log("Mouse moved");

button.addEventListener("click", clickHandler);
button.addEventListener("mouseover", mouseHandler);

console.log("Event listeners added");
console.log("Button listeners:", button.getEventListenersCount());

// Simulate element removal (memory leak scenario)
console.log("\n=== Simulating Element Removal (WITHOUT cleanup) ===");
let buttonRef = button;  // Keep reference to simulate memory leak
button = null;  // Remove button reference

console.log("Button reference removed but event listeners remain");
console.log("This creates a memory leak!");

// Proper cleanup (preventing memory leak)
console.log("\n=== Proper Cleanup (PREVENTING memory leak) ===");
const button2 = new DOMElement("button");
const clickHandler2 = () =&gt; console.log("Button 2 clicked");

button2.addEventListener("click", clickHandler2);
console.log("Button 2 listeners:", button2.getEventListenersCount());

// Remove event listener before removing element
button2.removeEventListener("click", clickHandler2);
console.log("Event listener removed");
console.log("Button 2 listeners:", button2.getEventListenersCount());

// Now safe to remove element
button2 = null;
console.log("Button 2 reference removed safely");

console.log("\n=== KEY INSIGHT ===");
console.log("Event listeners can cause memory leaks");
console.log("Always remove listeners before destroying elements");
console.log("Use removeEventListener() to prevent memory leaks");
```


</div>

<hr />

<h2 id="️-common-pitfalls">⚠️ Common Pitfalls</h2>

<h3 id="pitfall-1-global-variables">Pitfall 1: Global Variables</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ WRONG: Accidental global variable</span>
<span class="kd">function</span> <span class="nx">processData</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">result</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">processed</span><span class="dl">"</span><span class="p">;</span>  <span class="c1">// Missing 'let' or 'const'</span>
<span class="p">}</span>

<span class="c1">// ✅ CORRECT: Proper variable declaration</span>
<span class="kd">function</span> <span class="nx">processData</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">processed</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="pitfall-2-forgotten-event-listeners">Pitfall 2: Forgotten Event Listeners</h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ❌ WRONG: Event listener not removed</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
<span class="c1">// Element removed from DOM but listener remains</span>

<span class="c1">// ✅ CORRECT: Remove event listener</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="dl">"</span><span class="s2">click</span><span class="dl">"</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</code></pre></div></div>

<hr />

<h2 id="-best-practices">🎯 Best Practices</h2>

<h3 id="-dos">✅ Do’s:</h3>
<ul>
  <li><strong>Use <code class="language-plaintext highlighter-rouge">let</code> and <code class="language-plaintext highlighter-rouge">const</code></strong> instead of <code class="language-plaintext highlighter-rouge">var</code></li>
  <li><strong>Remove event listeners</strong> when elements are destroyed</li>
  <li><strong>Clear timers</strong> when they’re no longer needed</li>
  <li><strong>Avoid global variables</strong> and use proper scoping</li>
  <li><strong>Monitor memory usage</strong> in development</li>
</ul>

<h3 id="-donts">❌ Don’ts:</h3>
<ul>
  <li><strong>Don’t create circular references</strong> unnecessarily</li>
  <li><strong>Don’t forget to clean up</strong> event listeners and timers</li>
  <li><strong>Don’t store large objects</strong> in closures</li>
  <li><strong>Don’t ignore memory warnings</strong> in development tools</li>
</ul>

<hr />

<h2 id="-key-points">🔑 Key Points</h2>

<ul>
  <li><strong>Garbage Collection</strong> automatically manages memory in JavaScript</li>
  <li><strong>Reference Counting</strong> tracks object references (limited use)</li>
  <li><strong>Mark and Sweep</strong> is the primary GC algorithm (handles circular references)</li>
  <li><strong>Generational Collection</strong> optimizes GC for different object ages</li>
  <li><strong>Memory Leaks</strong> occur when memory is allocated but never freed</li>
  <li><strong>Event Listeners and Timers</strong> are common sources of memory leaks</li>
  <li><strong>Closures</strong> can hold references and cause memory leaks</li>
  <li><strong>Always clean up</strong> resources to prevent memory leaks</li>
</ul>

<hr />

<h2 id="-common-interview-questions">❓ Common Interview Questions</h2>

<h3 id="q1-what-is-garbage-collection-in-javascript">Q1: What is garbage collection in JavaScript?</h3>
<p><strong>A:</strong> Garbage collection is JavaScript’s automatic memory management system that identifies and frees memory that is no longer accessible by the program. It prevents memory leaks and manages memory allocation/deallocation automatically.</p>

<h3 id="q2-how-does-the-mark-and-sweep-algorithm-work">Q2: How does the Mark and Sweep algorithm work?</h3>
<p><strong>A:</strong> Mark and Sweep works in two phases: 1) Mark phase traverses from root objects and marks all reachable objects, 2) Sweep phase frees memory of unmarked (unreachable) objects. It handles circular references correctly.</p>

<h3 id="q3-what-are-common-causes-of-memory-leaks-in-javascript">Q3: What are common causes of memory leaks in JavaScript?</h3>
<p><strong>A:</strong> Common causes include: global variables, forgotten event listeners, uncleared timers (setInterval/setTimeout), circular references in closures, and holding references to DOM elements that are no longer in the document.</p>

<hr />

<h2 id="-copy-code-functionality">📋 Copy Code Functionality</h2>

<script src="../common-scripts.js"></script>

<hr />

<h2 id="-navigation">🧭 Navigation</h2>

<div class="navigation">
    <a href="12-Event-Loop-Concurrency.md" class="nav-link prev">← Previous: Event Loop &amp; Concurrency</a>
    <a href="01-Execution-Context-Call-Stack.md" class="nav-link next">Back to Start: Execution Context &amp; Call Stack →</a>
</div>

<p><em>Last updated: December 2024</em></p>

        </main>
        
        <footer style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #ecf0f1; color: #666; text-align: center;">
            <p>Interview Prep Documentation - Built with Jekyll</p>
        </footer>
    </div>
</body>
</html>
