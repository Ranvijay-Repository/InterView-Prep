# ğŸ”¹ Browser Performance

> **Comprehensive coverage of browser performance optimization: Critical rendering path optimization, Resource hints (preload, prefetch), and Service Worker caching strategies**

<link rel="stylesheet" href="../common-styles.css">

---

## ğŸ“š Table of Contents

- [Browser Performance Overview](#browser-performance-overview)
- [Critical Rendering Path Optimization](#critical-rendering-path-optimization)
- [Resource Hints (Preload, Prefetch)](#resource-hints-preload-prefetch)
- [Service Worker Caching Strategies](#service-worker-caching-strategies)
- [Detailed Examples](#detailed-examples)
- [Common Interview Questions](#common-interview-questions)
- [Practice Exercises](#practice-exercises)
- [Additional Resources](#additional-resources)

---

## ğŸ¯ Browser Performance Overview

**Browser Performance** focuses on optimizing how browsers render web pages, load resources, and manage caching to provide the fastest possible user experience.

### Why Browser Performance Matters:
- **User Experience**: Faster page loads and interactions
- **SEO Rankings**: Better Core Web Vitals scores
- **Conversion Rates**: Faster sites convert better
- **Mobile Performance**: Critical for mobile users
- **Competitive Advantage**: Outperform competitor sites

---

## ğŸš€ Critical Rendering Path Optimization

**Critical Rendering Path Optimization** involves optimizing the sequence of steps the browser takes to convert HTML, CSS, and JavaScript into pixels on the screen.

### Why Critical Rendering Path Matters:
- **First Paint**: Faster initial visual feedback
- **First Contentful Paint**: Quicker content display
- **Largest Contentful Paint**: Faster main content loading
- **Time to Interactive**: Quicker user interaction capability
- **Cumulative Layout Shift**: Stable visual layout

### ASCII Diagram: Critical Rendering Path
{% raw %}
```
CRITICAL RENDERING PATH
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        HTML DOCUMENT            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ <html>                      â”‚ â”‚
â”‚  â”‚ <head>                      â”‚ â”‚
â”‚  â”‚   <link rel="stylesheet">   â”‚ â”‚
â”‚  â”‚   <script src="app.js">     â”‚ â”‚
â”‚  â”‚ </head>                     â”‚ â”‚
â”‚  â”‚ <body>                      â”‚ â”‚
â”‚  â”‚   <div>Content</div>        â”‚ â”‚
â”‚  â”‚ </body>                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  DOM TREE     â”‚
        â”‚               â”‚
        â”‚  html         â”‚
        â”‚  â”œâ”€â”€ head     â”‚
        â”‚  â””â”€â”€ body     â”‚
        â”‚      â””â”€â”€ div  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  CSSOM TREE   â”‚
        â”‚               â”‚
        â”‚  stylesheet   â”‚
        â”‚  â”œâ”€â”€ body     â”‚
        â”‚  â””â”€â”€ div      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  RENDER TREE  â”‚
        â”‚               â”‚
        â”‚  body         â”‚
        â”‚  â””â”€â”€ div      â”‚
        â”‚      (styled) â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  LAYOUT       â”‚
        â”‚               â”‚
        â”‚  Calculate    â”‚
        â”‚  positions    â”‚
        â”‚  and sizes    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  PAINT        â”‚
        â”‚               â”‚
        â”‚  Fill pixels  â”‚
        â”‚  on screen    â”‚
        â”‚  (GPU)        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
{% endraw %}

### Optimization Techniques:
- **CSS Optimization**: Inline critical CSS, defer non-critical
- **JavaScript Optimization**: Defer non-critical scripts
- **HTML Optimization**: Minimize DOM size and complexity
- **Resource Prioritization**: Load critical resources first
- **Preloading**: Anticipate resource needs

---

## ğŸ”— Resource Hints (Preload, Prefetch)

**Resource Hints** are directives that tell the browser about resources it will likely need, enabling proactive resource loading and optimization.

### Why Resource Hints Matter:
- **Proactive Loading**: Load resources before they're needed
- **Performance Prediction**: Browser can optimize loading
- **User Experience**: Faster subsequent page loads
- **Bandwidth Optimization**: Efficient resource prioritization
- **Caching Strategy**: Better cache utilization

### ASCII Diagram: Resource Hints Flow
{% raw %}
```
RESOURCE HINTS FLOW
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        PAGE LOAD                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ HTML Parsing                â”‚ â”‚
â”‚  â”‚ Resource Discovery          â”‚ â”‚
â”‚  â”‚ Critical Path Resources    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  PRELOAD      â”‚
        â”‚  (Critical)   â”‚
        â”‚               â”‚
        â”‚  High Priorityâ”‚
        â”‚  Immediate    â”‚
        â”‚  Loading      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  PREFETCH     â”‚
        â”‚  (Likely)     â”‚
        â”‚               â”‚
        â”‚  Low Priority â”‚
        â”‚  Background   â”‚
        â”‚  Loading      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  PRECONNECT   â”‚
        â”‚  (Connection) â”‚
        â”‚               â”‚
        â”‚  DNS + TCP    â”‚
        â”‚  + TLS Setup  â”‚
        â”‚  (No Data)    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  PRERENDER    â”‚
        â”‚  (Full Page)  â”‚
        â”‚               â”‚
        â”‚  Background   â”‚
        â”‚  Page Render  â”‚
        â”‚  (Heavy)      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
{% endraw %}

### Resource Hint Types:
- **preload**: Critical resources for current page
- **prefetch**: Likely resources for future navigation
- **preconnect**: Establish early connections
- **prerender**: Full page preparation
- **dns-prefetch**: DNS resolution optimization

---

## ğŸ”„ Service Worker Caching Strategies

**Service Worker Caching Strategies** involve implementing different caching approaches to optimize resource delivery and provide offline functionality.

### Why Service Worker Caching Matters:
- **Offline Support**: Applications work without internet
- **Performance**: Faster resource loading from cache
- **User Experience**: Consistent app performance
- **Bandwidth Savings**: Reduce data usage
- **Reliability**: Handle network failures gracefully

### ASCII Diagram: Service Worker Caching
{% raw %}
```
SERVICE WORKER CACHING
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        BROWSER                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Page Request                â”‚ â”‚
â”‚  â”‚ Resource Request            â”‚ â”‚
â”‚  â”‚ API Request                 â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  SERVICE      â”‚
        â”‚  WORKER       â”‚
        â”‚               â”‚
        â”‚  Intercepts   â”‚
        â”‚  Requests     â”‚
        â”‚  Applies      â”‚
        â”‚  Strategy     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  CACHE        â”‚
        â”‚  STRATEGIES   â”‚
        â”‚               â”‚
        â”‚  Cache First  â”‚
        â”‚  Network Firstâ”‚
        â”‚  Stale While  â”‚
        â”‚  Revalidate   â”‚
        â”‚  Network Only â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  CACHE STORES â”‚
        â”‚               â”‚
        â”‚  Runtime      â”‚
        â”‚  Static       â”‚
        â”‚  Dynamic      â”‚
        â”‚  API          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  RESPONSE     â”‚
        â”‚               â”‚
        â”‚  From Cache   â”‚
        â”‚  From Network â”‚
        â”‚  Fallback     â”‚
        â”‚  Error        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
{% endraw %}

### Caching Strategies:
- **Cache First**: Serve from cache, fallback to network
- **Network First**: Try network, fallback to cache
- **Stale While Revalidate**: Serve stale, update in background
- **Network Only**: Always use network
- **Cache Only**: Always use cache

---

## ğŸ’» Detailed Examples

### Example 1: Critical Rendering Path Optimization
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">ğŸ“‹ Copy</button>
<pre><code>// Critical Rendering Path optimization implementation
class CriticalRenderingPathOptimizer {
    constructor() {
        this.performanceMetrics = new Map();
        this.criticalCSS = '';
        this.nonCriticalCSS = '';
        this.setupPerformanceMonitoring();
    }
    
    setupPerformanceMonitoring() {
        // Monitor key performance metrics
        this.observePerformanceMetrics();
        this.observeLayoutShifts();
        this.observeFirstPaint();
    }
    
    observePerformanceMetrics() {
        // Monitor Core Web Vitals
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    this.performanceMetrics.set(entry.name, entry);
                }
            });
            
            try {
                observer.observe({ entryTypes: ['measure', 'navigation', 'resource'] });
            } catch (e) {
                console.warn('PerformanceObserver not fully supported');
            }
        }
    }
    
    observeLayoutShifts() {
        // Monitor Cumulative Layout Shift (CLS)
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                let clsValue = 0;
                for (const entry of list.getEntries()) {
                    if (!entry.hadRecentInput) {
                        clsValue += entry.value;
                    }
                }
                this.performanceMetrics.set('CLS', clsValue);
            });
            
            try {
                observer.observe({ entryTypes: ['layout-shift'] });
            } catch (e) {
                console.warn('Layout shift observer not supported');
            }
        }
    }
    
    observeFirstPaint() {
        // Monitor First Paint and First Contentful Paint
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    this.performanceMetrics.set(entry.name, entry.startTime);
                }
            });
            
            try {
                observer.observe({ entryTypes: ['paint'] });
            } catch (e) {
                console.warn('Paint observer not supported');
            }
        }
    }
    
    // Inline critical CSS
    inlineCriticalCSS(criticalCSS) {
        performance.mark('critical-css-start');
        
        // Create style element for critical CSS
        const style = document.createElement('style');
        style.textContent = criticalCSS;
        document.head.appendChild(style);
        
        performance.mark('critical-css-end');
        performance.measure('critical-css-inline', 'critical-css-start', 'critical-css-end');
        
        this.criticalCSS = criticalCSS;
    }
    
    // Defer non-critical CSS
    deferNonCriticalCSS(cssUrl) {
        performance.mark('non-critical-css-start');
        
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = cssUrl;
        link.media = 'print';
        link.onload = () => {
            link.media = 'all';
            performance.mark('non-critical-css-end');
            performance.measure('non-critical-css-load', 'non-critical-css-start', 'non-critical-css-end');
        };
        
        document.head.appendChild(link);
        this.nonCriticalCSS = cssUrl;
    }
    
    // Optimize JavaScript loading
    optimizeJavaScriptLoading() {
        performance.mark('js-optimization-start');
        
        // Defer non-critical JavaScript
        const scripts = document.querySelectorAll('script[data-defer]');
        scripts.forEach(script => {
            script.setAttribute('defer', '');
        });
        
        // Async load non-critical scripts
        const asyncScripts = document.querySelectorAll('script[data-async]');
        asyncScripts.forEach(script => {
            script.setAttribute('async', '');
        });
        
        performance.mark('js-optimization-end');
        performance.measure('js-optimization', 'js-optimization-start', 'js-optimization-end');
    }
    
    // Optimize images
    optimizeImages() {
        performance.mark('image-optimization-start');
        
        // Lazy load images
        const images = document.querySelectorAll('img[data-src]');
        const imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    img.src = img.dataset.src;
                    img.classList.remove('lazy');
                    imageObserver.unobserve(img);
                }
            });
        });
        
        images.forEach(img => imageObserver.observe(img));
        
        // Use appropriate image formats
        const webpImages = document.querySelectorAll('img[data-webp]');
        webpImages.forEach(img => {
            if (this.supportsWebP()) {
                img.src = img.dataset.webp;
            }
        });
        
        performance.mark('image-optimization-end');
        performance.measure('image-optimization', 'image-optimization-start', 'image-optimization-end');
    }
    
    // Check WebP support
    supportsWebP() {
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
    }
    
    // Optimize fonts
    optimizeFonts() {
        performance.mark('font-optimization-start');
        
        // Preload critical fonts
        const criticalFonts = document.querySelectorAll('link[rel="preload"][as="font"]');
        criticalFonts.forEach(font => {
            font.setAttribute('crossorigin', '');
        });
        
        // Use font-display: swap for better performance
        const fontLinks = document.querySelectorAll('link[rel="stylesheet"][href*="font"]');
        fontLinks.forEach(link => {
            if (link.href.includes('googleapis.com')) {
                link.href += '&display=swap';
            }
        });
        
        performance.mark('font-optimization-end');
        performance.measure('font-optimization', 'font-optimization-start', 'font-optimization-end');
    }
    
    // Minimize DOM manipulation
    optimizeDOMManipulation() {
        performance.mark('dom-optimization-start');
        
        // Batch DOM updates
        const fragment = document.createDocumentFragment();
        const container = document.getElementById('dynamic-content');
        
        for (let i = 0; i < 1000; i++) {
            const div = document.createElement('div');
            div.textContent = `Item ${i}`;
            div.className = 'item';
            fragment.appendChild(div);
        }
        
        container.appendChild(fragment);
        
        performance.mark('dom-optimization-end');
        performance.measure('dom-optimization', 'dom-optimization-start', 'dom-optimization-end');
    }
    
    // Optimize event handling
    optimizeEventHandling() {
        performance.mark('event-optimization-start');
        
        // Use event delegation
        const container = document.getElementById('event-container');
        container.addEventListener('click', (event) => {
            if (event.target.matches('.button')) {
                this.handleButtonClick(event.target);
            } else if (event.target.matches('.link')) {
                this.handleLinkClick(event.target);
            }
        });
        
        // Debounce scroll events
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                this.handleScroll();
            }, 16); // ~60fps
        });
        
        performance.mark('event-optimization-end');
        performance.measure('event-optimization', 'event-optimization-start', 'event-optimization-end');
    }
    
    // Mock event handlers
    handleButtonClick(button) {
        console.log('Button clicked:', button.textContent);
    }
    
    handleLinkClick(link) {
        console.log('Link clicked:', link.href);
    }
    
    handleScroll() {
        // Handle scroll event
        console.log('Scroll position:', window.scrollY);
    }
    
    // Get performance metrics
    getPerformanceMetrics() {
        const metrics = {};
        
        // Core Web Vitals
        if (this.performanceMetrics.has('CLS')) {
            metrics.CLS = this.performanceMetrics.get('CLS');
        }
        
        if (this.performanceMetrics.has('first-paint')) {
            metrics.FP = this.performanceMetrics.get('first-paint');
        }
        
        if (this.performanceMetrics.has('first-contentful-paint')) {
            metrics.FCP = this.performanceMetrics.get('first-contentful-paint');
        }
        
        // Custom measures
        const measures = performance.getEntriesByType('measure');
        measures.forEach(measure => {
            metrics[measure.name] = measure.duration;
        });
        
        return metrics;
    }
    
    // Run all optimizations
    runAllOptimizations() {
        console.log('Running Critical Rendering Path optimizations...');
        
        // Inline critical CSS
        this.inlineCriticalCSS(`
            body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
            .header { background: #333; color: white; padding: 1rem; }
            .content { padding: 2rem; }
            .item { margin: 0.5rem 0; padding: 0.5rem; border: 1px solid #ddd; }
        `);
        
        // Defer non-critical CSS
        this.deferNonCriticalCSS('/styles/non-critical.css');
        
        // Optimize JavaScript loading
        this.optimizeJavaScriptLoading();
        
        // Optimize images
        this.optimizeImages();
        
        // Optimize fonts
        this.optimizeFonts();
        
        // Optimize DOM manipulation
        this.optimizeDOMManipulation();
        
        // Optimize event handling
        this.optimizeEventHandling();
        
        console.log('All optimizations completed.');
    }
}

// Usage example
const crpOptimizer = new CriticalRenderingPathOptimizer();

// Run optimizations after DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        crpOptimizer.runAllOptimizations();
    });
} else {
    crpOptimizer.runAllOptimizations();
}

// Get performance metrics after a delay
setTimeout(() => {
    const metrics = crpOptimizer.getPerformanceMetrics();
    console.log('Performance Metrics:', metrics);
}, 3000);
</code></pre>
</div>

### Example 2: Resource Hints Implementation
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">ğŸ“‹ Copy</button>
<pre><code>// Resource hints implementation for performance optimization
class ResourceHintsManager {
    constructor() {
        this.hints = new Map();
        this.performanceMetrics = new Map();
        this.setupPerformanceMonitoring();
    }
    
    setupPerformanceMonitoring() {
        // Monitor resource loading performance
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'resource') {
                        this.performanceMetrics.set(entry.name, {
                            duration: entry.duration,
                            transferSize: entry.transferSize,
                            initiatorType: entry.initiatorType,
                            timestamp: entry.startTime
                        });
                    }
                }
            });
            
            try {
                observer.observe({ entryTypes: ['resource'] });
            } catch (e) {
                console.warn('Resource performance observer not supported');
            }
        }
    }
    
    // Preload critical resources
    preloadResource(url, options = {}) {
        const {
            as = 'script',
            crossorigin = false,
            type = null,
            media = null
        } = options;
        
        const link = document.createElement('link');
        link.rel = 'preload';
        link.href = url;
        link.as = as;
        
        if (crossorigin) {
            link.crossOrigin = 'anonymous';
        }
        
        if (type) {
            link.type = type;
        }
        
        if (media) {
            link.media = media;
        }
        
        // Track preloaded resources
        this.hints.set(url, {
            type: 'preload',
            as: as,
            timestamp: Date.now(),
            element: link
        });
        
        document.head.appendChild(link);
        
        // Monitor loading performance
        link.onload = () => {
            this.performanceMetrics.set(`preload-${url}`, {
                status: 'loaded',
                timestamp: Date.now()
            });
        };
        
        link.onerror = () => {
            this.performanceMetrics.set(`preload-${url}`, {
                status: 'error',
                timestamp: Date.now()
                error: 'Failed to preload resource'
            });
        };
        
        return link;
    }
    
    // Prefetch likely resources
    prefetchResource(url, options = {}) {
        const {
            crossorigin = false,
            type = null,
            media = null
        } = options;
        
        const link = document.createElement('link');
        link.rel = 'prefetch';
        link.href = url;
        
        if (crossorigin) {
            link.crossOrigin = 'anonymous';
        }
        
        if (type) {
            link.type = type;
        }
        
        if (media) {
            link.media = media;
        }
        
        // Track prefetched resources
        this.hints.set(url, {
            type: 'prefetch',
            timestamp: Date.now(),
            element: link
        });
        
        document.head.appendChild(link);
        
        return link;
    }
    
    // Preconnect to external domains
    preconnectDomain(domain, options = {}) {
        const {
            crossorigin = true,
            dns = true,
            tcp = true,
            tls = true
        } = options;
        
        const link = document.createElement('link');
        link.rel = 'preconnect';
        link.href = domain;
        
        if (crossorigin) {
            link.crossOrigin = 'anonymous';
        }
        
        // Track preconnect resources
        this.hints.set(domain, {
            type: 'preconnect',
            options: { dns, tcp, tls },
            timestamp: Date.now(),
            element: link
        });
        
        document.head.appendChild(link);
        
        return link;
    }
    
    // DNS prefetch for external domains
    dnsPrefetch(domain) {
        const link = document.createElement('link');
        link.rel = 'dns-prefetch';
        link.href = domain;
        
        // Track DNS prefetch resources
        this.hints.set(domain, {
            type: 'dns-prefetch',
            timestamp: Date.now(),
            element: link
        });
        
        document.head.appendChild(link);
        
        return link;
    }
    
    // Prerender full page
    prerenderPage(url) {
        const link = document.createElement('link');
        link.rel = 'prerender';
        link.href = url;
        
        // Track prerender resources
        this.hints.set(url, {
            type: 'prerender',
            timestamp: Date.now(),
            element: link
        });
        
        document.head.appendChild(link);
        
        return link;
    }
    
    // Module preload for ES modules
    preloadModule(url, options = {}) {
        const {
            crossorigin = false,
            type = 'module'
        } = options;
        
        const link = document.createElement('link');
        link.rel = 'modulepreload';
        link.href = url;
        
        if (crossorigin) {
            link.crossOrigin = 'anonymous';
        }
        
        if (type) {
            link.type = type;
        }
        
        // Track module preload resources
        this.hints.set(url, {
            type: 'modulepreload',
            timestamp: Date.now(),
            element: link
        });
        
        document.head.appendChild(link);
        
        return link;
    }
    
    // Intelligent resource hinting based on user behavior
    setupIntelligentHints() {
        // Preload critical CSS and fonts
        this.preloadResource('/styles/critical.css', { as: 'style' });
        this.preloadResource('/fonts/main.woff2', { as: 'font', crossorigin: true });
        
        // Preconnect to external domains
        this.preconnectDomain('https://api.example.com');
        this.preconnectDomain('https://cdn.example.com');
        
        // DNS prefetch for analytics and third-party services
        this.dnsPrefetch('https://www.google-analytics.com');
        this.dnsPrefetch('https://fonts.googleapis.com');
        
        // Prefetch likely navigation targets
        this.prefetchResource('/about');
        this.prefetchResource('/contact');
        
        // Module preload for main application
        this.preloadModule('/js/app.js', { crossorigin: true });
    }
    
    // Dynamic resource hinting based on user interactions
    setupDynamicHints() {
        // Prefetch resources when user hovers over navigation
        const navLinks = document.querySelectorAll('nav a');
        navLinks.forEach(link => {
            link.addEventListener('mouseenter', () => {
                const url = link.href;
                if (!this.hints.has(url)) {
                    this.prefetchResource(url);
                }
            });
        });
        
        // Preload images when they come into view
        const images = document.querySelectorAll('img[data-src]');
        const imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    const src = img.dataset.src;
                    
                    if (src && !this.hints.has(src)) {
                        this.preloadResource(src, { as: 'image' });
                    }
                }
            });
        });
        
        images.forEach(img => imageObserver.observe(img));
    }
    
    // Remove resource hints
    removeHint(url) {
        const hint = this.hints.get(url);
        if (hint && hint.element) {
            hint.element.remove();
            this.hints.delete(url);
        }
    }
    
    // Clear all resource hints
    clearAllHints() {
        this.hints.forEach((hint, url) => {
            this.removeHint(url);
        });
    }
    
    // Get resource hint statistics
    getHintStatistics() {
        const stats = {
            total: this.hints.size,
            byType: {},
            performance: Array.from(this.performanceMetrics.values())
        };
        
        // Count by type
        this.hints.forEach((hint, url) => {
            const type = hint.type;
            stats.byType[type] = (stats.byType[type] || 0) + 1;
        });
        
        return stats;
    }
    
    // Monitor hint effectiveness
    monitorHintEffectiveness() {
        // Check if preloaded resources are actually used
        this.hints.forEach((hint, url) => {
            if (hint.type === 'preload') {
                // Monitor if the resource is loaded again
                const resourceEntries = performance.getEntriesByType('resource');
                const resource = resourceEntries.find(entry => entry.name === url);
                
                if (resource) {
                    this.performanceMetrics.set(`effectiveness-${url}`, {
                        wasPreloaded: true,
                        loadTime: resource.duration,
                        timestamp: Date.now()
                    });
                }
            }
        });
    }
}

// Usage example
const resourceHintsManager = new ResourceHintsManager();

// Setup intelligent resource hints
resourceHintsManager.setupIntelligentHints();

// Setup dynamic hints after DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        resourceHintsManager.setupDynamicHints();
    });
} else {
    resourceHintsManager.setupDynamicHints();
}

// Monitor hint effectiveness
setTimeout(() => {
    resourceHintsManager.monitorHintEffectiveness();
    const stats = resourceHintsManager.getHintStatistics();
    console.log('Resource Hints Statistics:', stats);
}, 5000);
</code></pre>
</div>

---

## ğŸ“‹ Copy Code Functionality

<script src="../common-scripts.js"></script>

---

## ğŸ§­ Navigation

<div class="navigation">
    <a href="01-JavaScript-Performance.md" class="nav-link prev">â† Previous: JavaScript Performance</a>
    <a href="03-Advanced-Optimization.md" class="nav-link next">Next: Advanced Optimization â†’</a>
</div>

*Last updated: December 2024*
