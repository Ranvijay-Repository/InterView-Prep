# 🧮 Functional Programming

> **Mastering functional programming concepts and patterns in JavaScript**

<link rel="stylesheet" href="../common-styles.css">

---

## 📋 Table of Contents

- [What is Functional Programming?](#what-is-functional-programming)
- [Core Principles](#core-principles)
- [Pure Functions](#pure-functions)
- [Immutability](#immutability)
- [Higher Order Functions](#higher-order-functions)
- [Function Composition](#function-composition)
- [Currying & Partial Application](#currying--partial-application)
- [Advanced FP Concepts](#advanced-fp-concepts)
- [Detailed Examples](#detailed-examples)
- [Common Pitfalls](#common-pitfalls)
- [Best Practices](#best-practices)
- [Key Points](#key-points)
- [Common Interview Questions](#common-interview-questions)
- [Practice Exercises](#practice-exercises)
- [Additional Resources](#additional-resources)

---

## 🎯 What is Functional Programming?

**Functional Programming (FP)** is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. In JavaScript, FP emphasizes writing code using pure functions, avoiding side effects, and treating functions as first-class citizens.

### Why Functional Programming Matters:
- **Predictable Code**: Pure functions always return the same output for the same input
- **Easier Testing**: Functions without side effects are easier to test
- **Better Performance**: Immutable data enables optimization
- **Concurrent Safety**: No shared state means no race conditions
- **Code Reusability**: Functions can be composed and reused easily

---

## 🔑 Core Principles

Functional Programming is built on several core principles:

### 1. **First-Class Functions**
Functions are treated as values that can be:
- Assigned to variables
- Passed as arguments
- Returned from other functions
- Stored in data structures

### 2. **Pure Functions**
- Same input always produces same output
- No side effects
- No external dependencies

### 3. **Immutability**
- Data cannot be changed after creation
- New data is created instead of modifying existing data

### 4. **Function Composition**
- Building complex functions by combining simpler ones
- Data flows through a pipeline of functions

---

## ✨ Pure Functions

**Pure Functions** are the foundation of functional programming. They have no side effects and always return the same output for the same input.

### Characteristics of Pure Functions:
- ✅ **Deterministic**: Same input → Same output
- ✅ **No Side Effects**: Don't modify external state
- ✅ **Referentially Transparent**: Can be replaced with their result
- ✅ **Easily Testable**: No external dependencies

### ASCII Diagram: Pure vs Impure Functions
{% raw %}
```
PURE FUNCTION                    IMPURE FUNCTION
┌─────────────────────────┐     ┌─────────────────────────┐
│ Input: 5                │     │ Input: 5                │
│ ↓                       │     │ ↓                       │
│ Process: x * 2          │     │ Process: x * 2          │
│ ↓                       │     │ ↓                       │
│ Output: 10              │     │ Output: 10              │
│                         │     │ + Modify global var     │
│ Always: 5 → 10          │     │ + Log to console        │
│ No side effects         │     │ + Make API call         │
└─────────────────────────┘     └─────────────────────────┘
```
{% endraw %}

### Examples:

{% raw %}
```javascript
// ✅ PURE FUNCTION
function add(a, b) {
    return a + b;
}

// ❌ IMPURE FUNCTION
let total = 0;
function addToTotal(value) {
    total += value;  // Side effect: modifies external state
    return total;
}
```
{% endraw %}

---

## 🔒 Immutability

**Immutability** means that once data is created, it cannot be changed. Instead, new data is created with the desired modifications.

### Why Immutability Matters:
- **Predictable State**: Data cannot change unexpectedly
- **Performance**: Enables optimization and memoization
- **Debugging**: Easier to track data changes
- **Concurrency**: No shared mutable state

### ASCII Diagram: Mutable vs Immutable Operations
{% raw %}
```
MUTABLE APPROACH              IMMUTABLE APPROACH
┌─────────────────────────┐   ┌─────────────────────────┐
│ Original Array: [1,2,3] │   │ Original Array: [1,2,3] │
│ ↓                       │   │ ↓                       │
│ array.push(4)           │   │ [...array, 4]           │
│ ↓                       │   │ ↓                       │
│ Original: [1,2,3,4]    │   │ New Array: [1,2,3,4]   │
│ (Modified!)              │   │ Original: [1,2,3]      │
│                         │   │ (Unchanged!)            │
└─────────────────────────┘   └─────────────────────────┘
```
{% endraw %}

### Immutability Techniques:

{% raw %}
```javascript
// Arrays
const original = [1, 2, 3];

// ❌ Mutable
original.push(4);  // Modifies original

// ✅ Immutable
const newArray = [...original, 4];  // Creates new array
const newArray2 = original.concat(4);  // Alternative
const newArray3 = [...original.slice(0, 2), 4, ...original.slice(2)];  // Insert at position

// Objects
const originalObj = { name: "John", age: 30 };

// ❌ Mutable
originalObj.age = 31;  // Modifies original

// ✅ Immutable
const newObj = { ...originalObj, age: 31 };  // Creates new object
const newObj2 = Object.assign({}, originalObj, { age: 31 });  // Alternative
```
{% endraw %}

---

## 🔝 Higher Order Functions

**Higher Order Functions (HOFs)** are functions that either:
1. Take one or more functions as arguments
2. Return a function as a result

### Common Higher Order Functions:

#### 1. **Array Methods**
{% raw %}
```javascript
// map, filter, reduce, forEach, find, some, every
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(x => x * 2);        // [2, 4, 6, 8, 10]
const evens = numbers.filter(x => x % 2 === 0); // [2, 4]
const sum = numbers.reduce((acc, x) => acc + x, 0); // 15
```
{% endraw %}

#### 2. **Custom Higher Order Functions**
{% raw %}
```javascript
// Function that takes a function and returns a function
function withLogging(fn) {
    return function(...args) {
        console.log(`Calling function with args:`, args);
        const result = fn(...args);
        console.log(`Function returned:`, result);
        return result;
    };
}

const addWithLogging = withLogging((a, b) => a + b);
addWithLogging(2, 3); // Logs the call and result
```
{% endraw %}

### ASCII Diagram: Higher Order Function Flow
{% raw %}
```
HIGHER ORDER FUNCTION PATTERN
┌─────────────────────────────────┐
│ Input Function                  │
│ function(x) { return x * 2 }   │
│ ↓                              │
│ Higher Order Function          │
│ withLogging(inputFunction)     │
│ ↓                              │
│ Returns Enhanced Function      │
│ function(...args) {            │
│   console.log(args);           │
│   return inputFunction(...args);│
│ }                              │
└─────────────────────────────────┘
```
{% endraw %}

---

## 🔗 Function Composition

**Function Composition** is the process of combining multiple functions to create a new function. The output of one function becomes the input of the next.

### Basic Composition:
{% raw %}
```javascript
// Simple composition
const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x ** 2;

// Compose functions manually
const result = square(double(addOne(5))); // 144

// Create a composition function
function compose(...fns) {
    return function(x) {
        return fns.reduceRight((acc, fn) => fn(acc), x);
    };
}

const composed = compose(square, double, addOne);
const result2 = composed(5); // 144
```
{% endraw %}

### ASCII Diagram: Function Composition
{% raw %}
```
FUNCTION COMPOSITION FLOW
┌─────────────────────────────────┐
│ Input: 5                        │
│ ↓                               │
│ addOne(5) → 6                  │
│ ↓                               │
│ double(6) → 12                 │
│ ↓                               │
│ square(12) → 144               │
│ ↓                               │
│ Output: 144                     │
└─────────────────────────────────┘

COMPOSITION PATTERN:
f(g(h(x))) = compose(f, g, h)(x)
```
{% endraw %}

### Pipe Function (Left to Right):
{% raw %}
```javascript
// Pipe function (left to right execution)
function pipe(...fns) {
    return function(x) {
        return fns.reduce((acc, fn) => fn(acc), x);
    };
}

const piped = pipe(addOne, double, square);
const result3 = piped(5); // 144

// Same as: square(double(addOne(5)))
```
{% endraw %}

---

## 🎯 Currying & Partial Application

**Currying** is the technique of converting a function that takes multiple arguments into a sequence of functions that each take a single argument.

### Basic Currying:
{% raw %}
```javascript
// Regular function
function add(a, b, c) {
    return a + b + c;
}

// Curried version
function curriedAdd(a) {
    return function(b) {
        return function(c) {
            return a + b + c;
        };
    };
}

// Usage
const result = curriedAdd(1)(2)(3); // 6

// Modern currying with arrow functions
const modernCurriedAdd = a => b => c => a + b + c;
```
{% endraw %}

### ASCII Diagram: Currying Process
{% raw %}
```
CURRYING TRANSFORMATION
┌─────────────────────────────────┐
│ Original Function               │
│ add(a, b, c) → a + b + c      │
│                                 │
│ ↓                              │
│ Curried Function               │
│ add(a) → function(b) →         │
│           function(c) → a + b + c│
│                                 │
│ Usage:                         │
│ add(1)(2)(3) → 6              │
└─────────────────────────────────┘
```
{% endraw %}

### Partial Application:
{% raw %}
```javascript
// Partial application - fixing some arguments
function partial(fn, ...fixedArgs) {
    return function(...remainingArgs) {
        return fn(...fixedArgs, ...remainingArgs);
    };
}

const addTen = partial(add, 10);
const result = addTen(5, 3); // 18 (10 + 5 + 3)

// Using bind for partial application
const addFive = add.bind(null, 5);
const result2 = addFive(3, 2); // 10 (5 + 3 + 2)
```
{% endraw %}

---

## 🚀 Advanced FP Concepts

### 1. **Point-Free Style (Tacit Programming)**
{% raw %}
```javascript
// With explicit parameters
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(x => double(x));

// Point-free style
const doubled = numbers.map(double);
```
{% endraw %}

### 2. **Function Memoization**
{% raw %}
```javascript
function memoize(fn) {
    const cache = new Map();
    
    return function(...args) {
        const key = JSON.stringify(args);
        if (cache.has(key)) {
            return cache.get(key);
        }
        
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
}

const expensiveOperation = memoize((n) => {
    console.log('Computing...');
    return n * 2;
});

expensiveOperation(5); // Computing... → 10
expensiveOperation(5); // 10 (from cache)
```
{% endraw %}

### 3. **Lazy Evaluation**
{% raw %}
```javascript
// Lazy array operations
function* lazyMap(array, fn) {
    for (const item of array) {
        yield fn(item);
    }
}

const lazyDoubled = lazyMap([1, 2, 3, 4, 5], x => x * 2);
// Nothing computed yet

// Only compute when needed
for (const value of lazyDoubled) {
    console.log(value); // 2, 4, 6, 8, 10
}
```
{% endraw %}

---

## 💻 Detailed Examples

### Example 1: Building a Functional Utility Library
<div style="position: relative;">
<button onclick="copyCode(this)" style="position: absolute; top: 10px; right: 10px; background: #007acc; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px;">📋 Copy</button>

{% raw %}
```javascript
console.log("=== BUILDING A FUNCTIONAL UTILITY LIBRARY ===");

// Utility functions
const add = (a, b) => a + b;
const subtract = (a, b) => a - b;
const multiply = (a, b) => a * b;
const divide = (a, b) => a / b;

// Higher order function for validation
const withValidation = (validator, fn) => {
    return function(...args) {
        if (!validator(...args)) {
            throw new Error("Validation failed");
        }
        return fn(...args);
    };
};

// Validation functions
const isNumber = (x) => typeof x === 'number' && !isNaN(x);
const isPositive = (x) => isNumber(x) && x > 0;
const isNonZero = (x) => isNumber(x) && x !== 0;

// Create validated functions
const safeAdd = withValidation(
    (...args) => args.every(isNumber),
    add
);

const safeDivide = withValidation(
    (a, b) => isNumber(a) && isNonZero(b),
    divide
);

const safeMultiply = withValidation(
    (...args) => args.every(isPositive),
    multiply
);

console.log("=== Testing Validated Functions ===");

try {
    console.log("safeAdd(5, 3):", safeAdd(5, 3));           // 8
    console.log("safeAdd(5, '3'):", safeAdd(5, '3'));       // Error: Validation failed
} catch (error) {
    console.log("Error:", error.message);
}

try {
    console.log("safeDivide(10, 2):", safeDivide(10, 2));   // 5
    console.log("safeDivide(10, 0):", safeDivide(10, 0));   // Error: Validation failed
} catch (error) {
    console.log("Error:", error.message);
}

try {
    console.log("safeMultiply(3, 4):", safeMultiply(3, 4)); // 12
    console.log("safeMultiply(-3, 4):", safeMultiply(-3, 4)); // Error: Validation failed
} catch (error) {
    console.log("Error:", error.message);
}

// Function composition utility
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

// Complex calculation pipeline
const calculateTax = pipe(
    (income) => income * 0.2,           // 20% tax
    (tax) => Math.round(tax * 100) / 100, // Round to 2 decimal places
    (tax) => Math.max(tax, 0)           // Ensure non-negative
);

console.log("\n=== Tax Calculation Pipeline ===");
console.log("calculateTax(50000):", calculateTax(50000));     // 10000
console.log("calculateTax(25000):", calculateTax(25000));     // 5000
console.log("calculateTax(0):", calculateTax(0));             // 0
```
{% endraw %}
</div>

### Example 2: Immutable Data Structures
<div style="position: relative;">
<button onclick="copyCode(this)" style="position: absolute; top: 10px; right: 10px; background: #007acc; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px;">📋 Copy</button>

{% raw %}
```javascript
console.log("=== IMMUTABLE DATA STRUCTURES ===");

// Immutable object operations
const createUser = (name, age, email) => ({ name, age, email });

const updateUser = (user, updates) => ({
    ...user,
    ...updates
});

const addUserProperty = (user, key, value) => ({
    ...user,
    [key]: value
});

const removeUserProperty = (user, key) => {
    const { [key]: removed, ...rest } = user;
    return rest;
};

// Immutable array operations
const addToArray = (array, item) => [...array, item];
const removeFromArray = (array, index) => [
    ...array.slice(0, index),
    ...array.slice(index + 1)
];
const updateArrayItem = (array, index, item) => [
    ...array.slice(0, index),
    item,
    ...array.slice(index + 1)
];

// Immutable nested object operations
const updateNestedProperty = (obj, path, value) => {
    if (path.length === 1) {
        return { ...obj, [path[0]]: value };
    }
    
    const [first, ...rest] = path;
    return {
        ...obj,
        [first]: updateNestedProperty(obj[first] || {}, rest, value)
    };
};

console.log("=== Testing Immutable Operations ===");

// Create initial user
const user = createUser("John Doe", 30, "john@example.com");
console.log("Initial user:", user);

// Update user
const updatedUser = updateUser(user, { age: 31 });
console.log("Updated user:", updatedUser);
console.log("Original user unchanged:", user);

// Add property
const userWithPhone = addUserProperty(user, "phone", "123-456-7890");
console.log("User with phone:", userWithPhone);

// Remove property
const userWithoutEmail = removeUserProperty(user, "email");
console.log("User without email:", userWithoutEmail);

// Nested object operations
const company = {
    name: "Tech Corp",
    departments: {
        engineering: {
            employees: ["Alice", "Bob"],
            budget: 100000
        }
    }
};

console.log("\n=== Nested Object Operations ===");
console.log("Original company:", company);

const updatedCompany = updateNestedProperty(
    company,
    ["departments", "engineering", "budget"],
    150000
);

console.log("Updated company:", updatedCompany);
console.log("Original unchanged:", company);

// Array operations
const numbers = [1, 2, 3, 4, 5];
console.log("\n=== Array Operations ===");
console.log("Original array:", numbers);

const withSix = addToArray(numbers, 6);
console.log("Added 6:", withSix);

const withoutThree = removeFromArray(numbers, 2);
console.log("Removed index 2:", withoutThree);

const updatedNumbers = updateArrayItem(numbers, 1, 20);
console.log("Updated index 1:", updatedNumbers);

console.log("Original array unchanged:", numbers);
```
{% endraw %}
</div>

### Example 3: Advanced Function Composition
<div style="position: relative;">
<button onclick="copyCode(this)" style="position: absolute; top: 10px; right: 10px; background: #007acc; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px;">📋 Copy</button>

{% raw %}
```javascript
console.log("=== ADVANCED FUNCTION COMPOSITION ===");

// Utility functions
const toUpperCase = str => str.toUpperCase();
const trim = str => str.trim();
const split = separator => str => str.split(separator);
const join = separator => arr => arr.join(separator);
const map = fn => arr => arr.map(fn);
const filter = fn => arr => arr.filter(fn);
const reduce = fn => initial => arr => arr.reduce(fn, initial);

// Advanced composition utilities
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

// Conditional composition
const when = (predicate, fn) => x => predicate(x) ? fn(x) : x;
const unless = (predicate, fn) => x => predicate(x) ? x : fn(x);

// Error handling composition
const tryCatch = (tryFn, catchFn) => x => {
    try {
        return tryFn(x);
    } catch (error) {
        return catchFn(error, x);
    }
};

// Logging composition
const withLogging = (label) => (fn) => (x) => {
    console.log(`${label} input:`, x);
    const result = fn(x);
    console.log(`${label} output:`, result);
    return result;
};

console.log("=== Basic Composition ===");

// String processing pipeline
const processString = pipe(
    trim,
    toUpperCase,
    split(' '),
    map(word => word.length > 3 ? word : word.toLowerCase()),
    join('-')
);

const result = processString("  hello world javascript  ");
console.log("Processed string:", result);

console.log("\n=== Conditional Composition ===");

// Process numbers conditionally
const processNumber = pipe(
    when(x => x < 0, x => Math.abs(x)),
    when(x => x > 100, x => 100),
    unless(x => Number.isInteger(x), x => Math.round(x))
);

console.log("processNumber(-5):", processNumber(-5));       // 5
console.log("processNumber(150):", processNumber(150));     // 100
console.log("processNumber(3.7):", processNumber(3.7));     // 4
console.log("processNumber(50):", processNumber(50));       // 50

console.log("\n=== Error Handling Composition ===");

// Safe division with error handling
const safeDivide = (divisor) => (dividend) => {
    if (divisor === 0) throw new Error("Division by zero");
    return dividend / divisor;
};

const safeDivideWithFallback = tryCatch(
    safeDivide(0),
    (error, dividend) => {
        console.log("Error occurred:", error.message);
        return dividend; // Return original value on error
    }
);

console.log("safeDivideWithFallback(10):", safeDivideWithFallback(10));

console.log("\n=== Logging Composition ===");

// Add logging to functions
const addWithLogging = withLogging("Addition")(add);
const result2 = addWithLogging(5, 3);

// Compose multiple logging functions
const processWithLogging = pipe(
    withLogging("Step 1")(x => x * 2),
    withLogging("Step 2")(x => x + 1),
    withLogging("Step 3")(x => x ** 2)
);

const result3 = processWithLogging(5);
```
{% endraw %}

### Example 4: Currying and Partial Application
<div style="position: relative;">
<button onclick="copyCode(this)" style="position: absolute; top: 10px; right: 10px; background: #007acc; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px;">📋 Copy</button>

{% raw %}
```javascript
console.log("=== CURRYING AND PARTIAL APPLICATION ===");

// Auto-currying utility
const curry = (fn) => {
    const arity = fn.length;
    
    function curried(...args) {
        if (args.length >= arity) {
            return fn(...args);
        }
        
        return function(...moreArgs) {
            return curried(...args, ...moreArgs);
        };
    }
    
    return curried;
};

// Partial application utility
const partial = (fn, ...fixedArgs) => {
    return function(...remainingArgs) {
        return fn(...fixedArgs, ...remainingArgs);
    };
};

// Practical examples
const formatMessage = curry((greeting, name, punctuation) => {
    return `${greeting}, ${name}${punctuation}`;
});

const greet = formatMessage("Hello");
const greetFormally = greet("Mr. Smith");
const finalGreeting = greetFormally("!");

console.log("=== Currying Examples ===");
console.log("formatMessage('Hi', 'John', '!'):", formatMessage("Hi", "John", "!"));
console.log("greet('John', '!'):", greet("John", "!"));
console.log("greetFormally('!'):", greetFormally("!"));
console.log("finalGreeting:", finalGreeting);

console.log("\n=== Partial Application Examples ===");

// Database query builder
const buildQuery = (table, fields, conditions, limit) => {
    return `SELECT ${fields.join(', ')} FROM ${table} WHERE ${conditions.join(' AND ')} LIMIT ${limit}`;
};

const queryUsers = partial(buildQuery, 'users', ['id', 'name', 'email']);
const queryActiveUsers = partial(queryUsers, ['status = "active"']);
const queryLimitedUsers = partial(queryActiveUsers, 10);

console.log("queryUsers(['status = "active"'], 5):", queryUsers(['status = "active"'], 5));
console.log("queryActiveUsers(5):", queryActiveUsers(5));
console.log("queryLimitedUsers:", queryLimitedUsers);

console.log("\n=== Practical Use Cases ===");

// Event handler with partial application
const createEventHandler = (eventType, element, handler) => {
    element.addEventListener(eventType, handler);
    return () => element.removeEventListener(eventType, handler);
};

const createClickHandler = partial(createEventHandler, 'click');
const createKeyHandler = partial(createEventHandler, 'keydown');

// Simulate DOM elements
const button = { addEventListener: () => {}, removeEventListener: () => {} };
const input = { addEventListener: () => {}, removeEventListener: () => {} };

const clickHandler = (event) => console.log('Button clicked:', event);
const keyHandler = (event) => console.log('Key pressed:', event.key);

const removeClickHandler = createClickHandler(button, clickHandler);
const removeKeyHandler = createKeyHandler(input, keyHandler);

console.log("Event handlers created with partial application");
console.log("removeClickHandler and removeKeyHandler are cleanup functions");

// Math operations with currying
const mathOps = {
    add: curry((a, b) => a + b),
    subtract: curry((a, b) => a - b),
    multiply: curry((a, b) => a * b),
    divide: curry((a, b) => a / b)
};

const addFive = mathOps.add(5);
const multiplyByThree = mathOps.multiply(3);
const subtractTen = mathOps.subtract(10);

console.log("\n=== Math Operations ===");
console.log("addFive(3):", addFive(3));                     // 8
console.log("multiplyByThree(4):", multiplyByThree(4));     // 12
console.log("subtractTen(15):", subtractTen(15));           // 5

// Compose curried functions
const calculate = pipe(
    addFive,
    multiplyByThree,
    subtractTen
);

console.log("calculate(2):", calculate(2));                 // (2 + 5) * 3 - 10 = 11
```
{% endraw %}

### Example 5: Real-World Functional Programming
<div style="position: relative;">
<button onclick="copyCode(this)" style="position: absolute; top: 10px; right: 10px; background: #007acc; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px;">📋 Copy</button>

{% raw %}
```javascript
console.log("=== REAL-WORLD FUNCTIONAL PROGRAMMING ===");

// E-commerce cart system using FP principles
const cart = {
    items: [],
    addItem: (item) => ({ ...cart, items: [...cart.items, item] }),
    removeItem: (itemId) => ({ 
        ...cart, 
        items: cart.items.filter(item => item.id !== itemId) 
    }),
    updateQuantity: (itemId, quantity) => ({
        ...cart,
        items: cart.items.map(item => 
            item.id === itemId ? { ...item, quantity } : item
        )
    })
};

// Pure functions for cart operations
const calculateSubtotal = (items) => 
    items.reduce((sum, item) => sum + (item.price * item.quantity), 0);

const calculateTax = (subtotal, taxRate) => subtotal * taxRate;
const calculateShipping = (subtotal, threshold = 100) => 
    subtotal >= threshold ? 0 : 10;

const calculateTotal = (subtotal, tax, shipping) => 
    subtotal + tax + shipping;

// Discount functions
const applyDiscount = (discountType, amount) => (subtotal) => {
    switch (discountType) {
        case 'percentage':
            return subtotal * (1 - amount / 100);
        case 'fixed':
            return Math.max(subtotal - amount, 0);
        default:
            return subtotal;
    }
};

const isEligibleForDiscount = (user, cart) => {
    const total = calculateSubtotal(cart.items);
    return user.isVIP || total > 200 || user.couponCode;
};

// User validation
const validateUser = (user) => {
    const errors = [];
    
    if (!user.email || !user.email.includes('@')) {
        errors.push('Invalid email');
    }
    
    if (!user.name || user.name.trim().length < 2) {
        errors.push('Name must be at least 2 characters');
    }
    
    if (user.age && (user.age < 13 || user.age > 120)) {
        errors.push('Invalid age');
    }
    
    return {
        isValid: errors.length === 0,
        errors,
        user: errors.length === 0 ? user : null
    };
};

console.log("=== Cart Operations ===");

// Sample items
const items = [
    { id: 1, name: "Laptop", price: 999, quantity: 1 },
    { id: 2, name: "Mouse", price: 25, quantity: 2 },
    { id: 3, name: "Keyboard", price: 75, quantity: 1 }
];

// Create cart with items
let currentCart = { ...cart, items };
console.log("Initial cart:", currentCart);

// Add item
currentCart = cart.addItem.call(currentCart, { 
    id: 4, name: "Headphones", price: 150, quantity: 1 
});
console.log("After adding headphones:", currentCart);

// Update quantity
currentCart = cart.updateQuantity.call(currentCart, 2, 3);
console.log("After updating mouse quantity:", currentCart);

// Calculate totals
const subtotal = calculateSubtotal(currentCart.items);
const tax = calculateTax(subtotal, 0.08); // 8% tax
const shipping = calculateShipping(subtotal);
const total = calculateTotal(subtotal, tax, shipping);

console.log("\n=== Price Calculation ===");
console.log("Subtotal:", subtotal);
console.log("Tax (8%):", tax);
console.log("Shipping:", shipping);
console.log("Total:", total);

// Apply discount
const user = { isVIP: true, email: "vip@example.com", name: "VIP User" };
const discountEligible = isEligibleForDiscount(user, currentCart);

if (discountEligible) {
    const applyVIPDiscount = applyDiscount('percentage', 15);
    const discountedSubtotal = applyVIPDiscount(subtotal);
    const finalTotal = calculateTotal(discountedSubtotal, tax, shipping);
    
    console.log("\n=== Discount Applied ===");
    console.log("VIP Discount (15%):", subtotal - discountedSubtotal);
    console.log("Final Total:", finalTotal);
}

// User validation
console.log("\n=== User Validation ===");
const validUser = validateUser(user);
console.log("User validation result:", validUser);

const invalidUser = { email: "invalid", name: "A", age: 5 };
const invalidUserResult = validateUser(invalidUser);
console.log("Invalid user validation:", invalidUserResult);

// Functional data transformation
const processOrder = pipe(
    (cart) => ({ ...cart, subtotal: calculateSubtotal(cart.items) }),
    (cart) => ({ ...cart, tax: calculateTax(cart.subtotal, 0.08) }),
    (cart) => ({ ...cart, shipping: calculateShipping(cart.subtotal) }),
    (cart) => ({ 
        ...cart, 
        total: calculateTotal(cart.subtotal, cart.tax, cart.shipping) 
    })
);

const processedOrder = processOrder(currentCart);
console.log("\n=== Processed Order ===");
console.log("Processed order:", processedOrder);
```
{% endraw %}

---

## ⚠️ Common Pitfalls

### Pitfall 1: Over-Engineering Simple Problems
{% raw %}
```javascript
// ❌ WRONG: Over-engineered solution
const add = curry((a, b) => a + b);
const result = add(5)(3);

// ✅ CORRECT: Simple solution
const add = (a, b) => a + b;
const result = add(5, 3);
```
{% endraw %}

### Pitfall 2: Ignoring Performance
{% raw %}
```javascript
// ❌ WRONG: Creating new arrays in loops
const processArray = (arr) => {
    let result = [];
    for (let i = 0; i < arr.length; i++) {
        result = [...result, arr[i] * 2]; // Creates new array each iteration
    }
    return result;
};

// ✅ CORRECT: Efficient approach
const processArray = (arr) => arr.map(x => x * 2);
```
{% endraw %}

### Pitfall 3: Forgetting Error Handling
{% raw %}
```javascript
// ❌ WRONG: No error handling
const divide = (a, b) => a / b;

// ✅ CORRECT: With error handling
const divide = (a, b) => {
    if (b === 0) throw new Error("Division by zero");
    return a / b;
};
```
{% endraw %}

---

## 🎯 Best Practices

### ✅ Do's:
- **Start simple** and add complexity only when needed
- **Use pure functions** for predictable behavior
- **Embrace immutability** for better debugging
- **Compose functions** for reusability
- **Handle errors gracefully** in functional pipelines

### ❌ Don'ts:
- **Don't over-engineer** simple problems
- **Don't ignore performance** implications
- **Don't forget error handling** in functional code
- **Don't mix paradigms** unnecessarily

---

## 🔑 Key Points

- **Functional Programming** emphasizes pure functions and immutability
- **Pure functions** have no side effects and are predictable
- **Immutability** prevents unexpected state changes
- **Higher Order Functions** take or return functions
- **Function Composition** combines functions for complex operations
- **Currying** converts multi-argument functions to single-argument chains
- **Partial Application** fixes some arguments of a function
- **Start simple** and add complexity only when needed

---

## ❓ Common Interview Questions

<div class="interview-question">
    <h4>Q1: What is functional programming and why use it?</h4>
    <button class="solution-toggle-btn" onclick="toggleSolution(this)">Show Solution</button>
    <div class="solution">
        <p><strong>A:</strong> Functional programming is a paradigm that treats computation as mathematical functions, emphasizing pure functions, immutability, and function composition. Benefits include predictable code, easier testing, better performance through optimization, and concurrent safety.</p>
    </div>
</div>

<div class="interview-question">
    <h4>Q2: What's the difference between a pure and impure function?</h4>
    <button class="solution-toggle-btn" onclick="toggleSolution(this)">Show Solution</button>
    <div class="solution">
        <p><strong>A:</strong> Pure functions always return the same output for the same input and have no side effects. Impure functions may modify external state, make API calls, or produce different outputs for the same inputs.</p>
    </div>
</div>

<div class="interview-question">
    <h4>Q3: How do you implement immutability in JavaScript?</h4>
    <button class="solution-toggle-btn" onclick="toggleSolution(this)">Show Solution</button>
    <div class="solution">
        <p><strong>A:</strong> Use spread operator (<code>...</code>), <code>Object.assign()</code>, <code>Array.slice()</code>, and other methods that create new objects/arrays instead of modifying existing ones. Libraries like Immutable.js can also help.</p>
    </div>
</div>

<div class="interview-question">
    <h4>Q4: What is currying and when would you use it?</h4>
    <button class="solution-toggle-btn" onclick="toggleSolution(this)">Show Solution</button>
    <div class="solution">
        <p><strong>A:</strong> Currying converts a function that takes multiple arguments into a sequence of functions that each take a single argument. It's useful for partial application, creating reusable function templates, and building function pipelines.</p>
    </div>
</div>

<div class="interview-question">
    <h4>Q5: How do you handle errors in functional programming?</h4>
    <button class="solution-toggle-btn" onclick="toggleSolution(this)">Show Solution</button>
    <div class="solution">
        <p><strong>A:</strong> Use try-catch wrappers, return Result/Either types, or use functional error handling libraries. The key is to handle errors as part of the data flow rather than throwing exceptions.</p>
    </div>
</div>

---

## 🏋️ Practice Exercises

<div class="practice-exercise">
    <h4>Exercise 1: Pure Function Validator</h4>
    <p>Create a function that analyzes code and determines if functions are pure.</p>
    <button class="solution-toggle-btn" onclick="toggleSolution(this)">Show Solution</button>
    <div class="solution">
        <div style="position: relative;">
            <button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
            <pre><code>function isPureFunction(fn, testCases = []) {
    try {
        // Check for common impure patterns
        const fnString = fn.toString();
        
        // Check for global variable access
        if (fnString.includes('window.') || fnString.includes('global.')) {
            return false;
        }
        
        // Check for console.log, alert, etc.
        if (fnString.includes('console.') || fnString.includes('alert(')) {
            return false;
        }
        
        // Check for Date.now(), Math.random()
        if (fnString.includes('Date.now()') || fnString.includes('Math.random()')) {
            return false;
        }
        
        // Test with provided test cases
        if (testCases.length > 0) {
            const results = testCases.map(testCase => fn(...testCase.input));
            const results2 = testCases.map(testCase => fn(...testCase.input));
            
            // Check if results are consistent
            return results.every((result, index) => 
                JSON.stringify(result) === JSON.stringify(results2[index])
            );
        }
        
        return true;
    } catch (error) {
        return false;
    }
}

// Example usage
const pureFn = (a, b) => a + b;
const impureFn = (a, b) => {
    console.log(a + b);
    return a + b;
};

console.log(isPureFunction(pureFn)); // true
console.log(isPureFunction(impureFn)); // false</code></pre>
        </div>
    </div>
</div>

<div class="practice-exercise">
    <h4>Exercise 2: Immutable Data Structure Library</h4>
    <p>Implement a library for immutable arrays, objects, and maps with common operations.</p>
    <button class="solution-toggle-btn" onclick="toggleSolution(this)">Show Solution</button>
    <div class="solution">
        <div style="position: relative;">
            <button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
            <pre><code>class ImmutableArray {
    constructor(array = []) {
        this._array = [...array];
    }
    
    push(item) {
        return new ImmutableArray([...this._array, item]);
    }
    
    pop() {
        return new ImmutableArray(this._array.slice(0, -1));
    }
    
    set(index, item) {
        const newArray = [...this._array];
        newArray[index] = item;
        return new ImmutableArray(newArray);
    }
    
    filter(predicate) {
        return new ImmutableArray(this._array.filter(predicate));
    }
    
    map(transform) {
        return new ImmutableArray(this._array.map(transform));
    }
    
    toArray() {
        return [...this._array];
    }
    
    get length() {
        return this._array.length;
    }
}

class ImmutableObject {
    constructor(obj = {}) {
        this._obj = { ...obj };
    }
    
    set(key, value) {
        return new ImmutableObject({ ...this._obj, [key]: value });
    }
    
    delete(key) {
        const newObj = { ...this._obj };
        delete newObj[key];
        return new ImmutableObject(newObj);
    }
    
    merge(otherObj) {
        return new ImmutableObject({ ...this._obj, ...otherObj });
    }
    
    toObject() {
        return { ...this._obj };
    }
}

// Usage
const arr = new ImmutableArray([1, 2, 3]);
const newArr = arr.push(4).map(x => x * 2);
console.log(arr.toArray()); // [1, 2, 3]
console.log(newArr.toArray()); // [2, 4, 6, 8]

const obj = new ImmutableObject({ name: 'John', age: 30 });
const newObj = obj.set('age', 31).set('city', 'NYC');
console.log(obj.toObject()); // { name: 'John', age: 30 }
console.log(newObj.toObject()); // { name: 'John', age: 31, city: 'NYC' }</code></pre>
        </div>
    </div>
</div>

<div class="practice-exercise">
    <h4>Exercise 3: Function Composition Framework</h4>
    <p>Build a framework for composing functions with error handling, logging, and validation.</p>
    <button class="solution-toggle-btn" onclick="toggleSolution(this)">Show Solution</button>
    <div class="solution">
        <div style="position: relative;">
            <button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
            <pre><code>class FunctionComposer {
    constructor() {
        this.middleware = [];
    }
    
    use(middleware) {
        this.middleware.push(middleware);
        return this;
    }
    
    compose(...fns) {
        return (input) => {
            let result = input;
            
            // Apply middleware before each function
            for (const fn of fns) {
                try {
                    // Run middleware
                    for (const mw of this.middleware) {
                        result = mw.before ? mw.before(result) : result;
                    }
                    
                    // Execute function
                    result = fn(result);
                    
                    // Run middleware after
                    for (const mw of this.middleware) {
                        result = mw.after ? mw.after(result) : result;
                    }
                } catch (error) {
                    // Run error middleware
                    for (const mw of this.middleware) {
                        if (mw.error) {
                            result = mw.error(error, result);
                        }
                    }
                }
            }
            
            return result;
        };
    }
}

// Middleware examples
const loggingMiddleware = {
    before: (input) => {
        console.log('Input:', input);
        return input;
    },
    after: (output) => {
        console.log('Output:', output);
        return output;
    }
};

const validationMiddleware = {
    before: (input) => {
        if (typeof input !== 'number') {
            throw new Error('Input must be a number');
        }
        return input;
    }
};

const errorHandlingMiddleware = {
    error: (error, input) => {
        console.error('Error occurred:', error.message);
        return input; // Return original input on error
    }
};

// Usage
const composer = new FunctionComposer()
    .use(loggingMiddleware)
    .use(validationMiddleware)
    .use(errorHandlingMiddleware);

const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x ** 2;

const composed = composer.compose(addOne, double, square);

console.log(composed(5)); // Will log each step and handle errors</code></pre>
        </div>
    </div>
</div>

---

## 📚 Additional Resources

- [MDN: Functional Programming](https://developer.mozilla.org/en-US/docs/Glossary/Functional_programming)
- [Eloquent JavaScript: Functional Programming](https://eloquentjavascript.net/1st_edition/chapter6.html)
- [Mostly Adequate Guide to FP](https://mostly-adequate.gitbook.io/mostly-adequate-guide/)
- [Functional Light JavaScript](https://github.com/getify/Functional-Light-JS)

---

## 📋 Copy Code Functionality

<script src="../common-scripts.js"></script>



---

## 🧭 Navigation

<div class="navigation">
    <a href="../01%20JavaScript%20Core/13-Garbage-Collection.md" class="nav-link prev">← Previous: JavaScript Core Foundations</a>
    <a href="02-Object-Oriented-JavaScript.md" class="nav-link next">Next: Object-Oriented JavaScript →</a>
</div>

*Last updated: December 2024*
