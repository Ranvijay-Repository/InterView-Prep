# ğŸ”¹ Advanced Asynchronous JavaScript

> **Senior-level async concepts: AbortController, top-level await, Promise.withResolvers(), and advanced patterns**

<link rel="stylesheet" href="../common-styles.css">

---

## ğŸ“š Table of Contents

- [AbortController & Signal Handling](#abortcontroller--signal-handling)
- [Top-Level Await](#top-level-await)
- [Promise.withResolvers()](#promisewithresolvers)
- [Advanced Async Patterns](#advanced-async-patterns)
- [Detailed Examples](#detailed-examples)
- [Common Interview Questions](#common-interview-questions)
- [Practice Exercises](#practice-exercises)
- [Additional Resources](#additional-resources)

---

## ğŸ›‘ AbortController & Signal Handling

**AbortController** provides a way to cancel one or more Web API requests. It's essential for managing long-running operations and preventing unnecessary work.

### Why AbortController Matters:
- **Resource Management**: Cancel requests when they're no longer needed
- **User Experience**: Stop operations when users navigate away
- **Performance**: Prevent unnecessary network calls and processing
- **Memory Leaks**: Avoid memory leaks from abandoned operations

---

## âš¡ Top-Level Await

**Top-level await** allows you to use `await` at the top level of modules, making it easier to initialize applications and handle async setup.

### Use Cases:
- **Module Initialization**: Async setup when modules load
- **Configuration Loading**: Load config files asynchronously
- **Database Connections**: Establish connections during startup
- **API Initialization**: Set up API clients with async operations

### ASCII Diagram: Top-Level Await Flow
{% raw %}
```
TOP-LEVEL AWAIT FLOW
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        MODULE LOADING           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ import './config.js'        â”‚ â”‚
â”‚  â”‚                             â”‚ â”‚
â”‚  â”‚ const config = await        â”‚ â”‚
â”‚  â”‚   loadConfig();             â”‚ â”‚
â”‚  â”‚                             â”‚ â”‚
â”‚  â”‚ export { config };          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  AWAIT        â”‚
        â”‚  Execution    â”‚
        â”‚  Pauses       â”‚
        â”‚  Module       â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  RESOLUTION   â”‚
        â”‚  Module       â”‚
        â”‚  Continues    â”‚
        â”‚  Loading      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
{% endraw %}

---

## ğŸ”„ Promise.withResolvers()

**Promise.withResolvers()** creates a Promise with external resolve and reject functions, useful for scenarios where you need to control Promise resolution from outside.

### Why Promise.withResolvers() Matters:
- **External Control**: Resolve/reject from outside the Promise
- **Event-Based Resolution**: Resolve based on external events
- **Manual Control**: Fine-grained control over Promise lifecycle
- **Testing**: Easier to test async code with external control

### ASCII Diagram: Promise.withResolvers Pattern
{% raw %}
```
PROMISE.WITHRESOLVERS PATTERN
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    EXTERNAL CONTEXT             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ const { promise,            â”‚ â”‚
â”‚  â”‚       resolve, reject } =   â”‚ â”‚
â”‚  â”‚   Promise.withResolvers();  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   PROMISE     â”‚
        â”‚  Pending      â”‚
        â”‚  State        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  RESOLVE/     â”‚
        â”‚  REJECT       â”‚
        â”‚  Functions    â”‚
        â”‚  Available    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  EXTERNAL     â”‚
        â”‚  Control      â”‚
        â”‚  Over         â”‚
        â”‚  Resolution   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
{% endraw %}

---

## ğŸš€ Advanced Async Patterns

### 1. **Async Iterator Pattern**
{% raw %}
```javascript
class AsyncDataStream {
    constructor(data) {
        this.data = data;
        this.index = 0;
    }
    
    async *[Symbol.asyncIterator]() {
        while (this.index < this.data.length) {
            // Simulate async processing
            await new Promise(resolve => setTimeout(resolve, 100));
            yield this.data[this.index++];
        }
    }
}

// Usage
const stream = new AsyncDataStream([1, 2, 3, 4, 5]);
for await (const item of stream) {
    console.log(item);
}
```
{% endraw %}

### 2. **Async Generator Functions**
{% raw %}
```javascript
async function* asyncGenerator() {
    yield await fetchData(1);
    yield await fetchData(2);
    yield await fetchData(3);
}

// Usage
for await (const data of asyncGenerator()) {
    console.log(data);
}
```
{% endraw %}

---

## ğŸ’» Detailed Examples

### Example 1: AbortController with Fetch
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">ğŸ“‹ Copy</button>
<pre><code>class APIClient {
    constructor() {
        this.controller = null;
    }
    
    async fetchWithTimeout(url, timeout = 5000) {
        // Abort previous request if it exists
        if (this.controller) {
            this.controller.abort();
        }
        
        // Create new AbortController
        this.controller = new AbortController();
        
        // Set timeout
        const timeoutId = setTimeout(() => {
            this.controller.abort();
        }, timeout);
        
        try {
            const response = await fetch(url, {
                signal: this.controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            return await response.json();
        } catch (error) {
            if (error.name === 'AbortError') {
                throw new Error('Request was aborted');
            }
            throw error;
        }
    }
    
    abort() {
        if (this.controller) {
            this.controller.abort();
        }
    }
}

// Usage
const client = new APIClient();

// Start request
const requestPromise = client.fetchWithTimeout('https://api.example.com/data', 3000);

// Abort after 1 second
setTimeout(() => {
    client.abort();
    console.log('Request aborted');
}, 1000);

// Handle result
try {
    const data = await requestPromise;
    console.log('Data received:', data);
} catch (error) {
    console.error('Error:', error.message);
}
</code></pre>
</div>

### Example 2: Top-Level Await in Modules
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">ğŸ“‹ Copy</button>
<pre><code>// config.js - Module with top-level await
const config = await loadConfiguration();

async function loadConfiguration() {
    try {
        // Load environment-specific config
        const env = process.env.NODE_ENV || 'development';
        const configPath = `./config.${env}.json`;
        
        const response = await fetch(configPath);
        if (!response.ok) {
            throw new Error(`Failed to load config: ${response.status}`);
        }
        
        return await response.json();
    } catch (error) {
        console.warn('Using default config:', error.message);
        return {
            port: 3000,
            database: 'localhost',
            debug: true
        };
    }
}

export { config };

// app.js - Using the config module
import { config } from './config.js';

console.log('App starting with config:', config);

// The app won't start until config is loaded
const app = {
    port: config.port,
    database: config.database,
    debug: config.debug
};

export default app;
</code></pre>
</div>

### Example 3: Promise.withResolvers() Implementation
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">ğŸ“‹ Copy</button>
<pre><code>// Custom implementation of Promise.withResolvers (for older environments)
function createPromiseWithResolvers() {
    let resolve, reject;
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    
    return { promise, resolve, reject };
}

// Event-based Promise resolution
class EventPromise {
    constructor() {
        const { promise, resolve, reject } = createPromiseWithResolvers();
        this.promise = promise;
        this.resolve = resolve;
        this.reject = reject;
    }
}

// Usage: Promise that resolves on button click
function createClickPromise(button) {
    const { promise, resolve, reject } = createPromiseWithResolvers();
    
    const clickHandler = () => {
        resolve('Button clicked!');
        button.removeEventListener('click', clickHandler);
    };
    
    const timeoutHandler = () => {
        reject(new Error('Button click timeout'));
        button.removeEventListener('click', clickHandler);
    };
    
    button.addEventListener('click', clickHandler);
    
    // Set timeout
    setTimeout(timeoutHandler, 5000);
    
    return promise;
}

// Usage
const button = document.getElementById('myButton');
const clickPromise = createClickPromise(button);

try {
    const result = await clickPromise;
    console.log(result); // "Button clicked!"
} catch (error) {
    console.error('Error:', error.message); // "Button click timeout"
}
</code></pre>
</div>

### Example 4: Advanced AbortController Patterns
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">ğŸ“‹ Copy</button>
<pre><code>// AbortController with multiple operations
class MultiOperationController {
    constructor() {
        this.controller = new AbortController();
        this.operations = new Set();
    }
    
    // Add operation to track
    addOperation(operation) {
        this.operations.add(operation);
        operation.finally(() => {
            this.operations.delete(operation);
        });
    }
    
    // Abort all operations
    abortAll() {
        this.controller.abort();
        this.operations.forEach(op => {
            if (op.abort) op.abort();
        });
    }
    
    // Create new signal for child operations
    createSignal() {
        return this.controller.signal;
    }
}

// Usage with multiple fetch operations
const controller = new MultiOperationController();

async function fetchMultipleData(urls) {
    const promises = urls.map(async (url) => {
        const operation = fetch(url, {
            signal: controller.createSignal()
        });
        
        controller.addOperation(operation);
        return operation;
    });
    
    try {
        const results = await Promise.all(promises);
        return results.map(r => r.json());
    } catch (error) {
        if (error.name === 'AbortError') {
            console.log('All operations aborted');
        }
        throw error;
    }
}

// Start operations
const dataPromise = fetchMultipleData([
    'https://api.example.com/users',
    'https://api.example.com/posts',
    'https://api.example.com/comments'
]);

// Abort all after 3 seconds
setTimeout(() => {
    controller.abortAll();
    console.log('All operations aborted');
}, 3000);

// Handle results
try {
    const data = await dataPromise;
    console.log('All data received:', data);
} catch (error) {
    console.error('Error:', error.message);
}
</code></pre>
</div>

---

## â“ Common Interview Questions

### Q1: What is AbortController and when would you use it?
**A:** AbortController provides a way to cancel one or more Web API requests. It's useful for canceling requests when they're no longer needed (user navigation, component unmounting), implementing timeouts, or providing user control over long-running operations. It helps prevent memory leaks and unnecessary network calls.

### Q2: How does top-level await work and what are its limitations?
**A:** Top-level await allows you to use `await` at the module level, making it easier to initialize applications with async setup. It's only available in ES modules and the module won't be considered "loaded" until all top-level awaits resolve. It's great for configuration loading, database connections, and API initialization.

### Q3: What is Promise.withResolvers() and how does it differ from new Promise()?
**A:** Promise.withResolvers() creates a Promise with external resolve and reject functions, while new Promise() creates a Promise with internal resolve/reject functions. The external approach is useful when you need to control Promise resolution from outside the Promise constructor, such as in event-based scenarios or when you need manual control over timing.

### Q4: How can you implement request cancellation in a React component?
**A:** Use AbortController in useEffect cleanup or component unmount. Create an AbortController in the component, pass its signal to fetch requests, and call controller.abort() in the cleanup function. This prevents memory leaks and ensures requests are cancelled when the component unmounts.

### Q5: What are the performance implications of top-level await?
**A:** Top-level await can delay module loading since the module isn't considered "ready" until all awaits resolve. This can impact application startup time. However, it provides better error handling and ensures dependencies are properly initialized before the module is used.

---

## ğŸ‹ï¸ Practice Exercises

### Exercise 1: Implement a Request Queue with AbortController
Create a request queue that can process multiple requests with individual abort capabilities and overall queue control.

### Exercise 2: Build an Async Data Stream
Implement an async iterator that streams data from an API with configurable chunk sizes and abort functionality.

### Exercise 3: Create a Module Initialization System
Build a system using top-level await that loads configuration, establishes database connections, and initializes services in the correct order.

---

## ğŸ“š Additional Resources

- **AbortController**: [MDN AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)
- **Top-Level Await**: [V8 Blog - Top-level await](https://v8.dev/features/top-level-await)
- **Promise.withResolvers**: [TC39 Proposal](https://github.com/tc39/proposal-promise-with-resolvers)
- **Async Patterns**: [JavaScript Async Patterns](https://javascript.info/async)

---

## ğŸ“‹ Copy Code Functionality

<script src="../common-scripts.js"></script>

---

## ğŸ§­ Navigation

<div class="navigation">
    <a href="03-Asynchronous-JavaScript.md" class="nav-link prev">â† Previous: Asynchronous JavaScript Basics</a>
    <a href="04-Modules.md" class="nav-link next">Next: Modules & Module Systems â†’</a>
</div>

*Last updated: December 2024*
