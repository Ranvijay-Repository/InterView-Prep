# 🔹 ES2021+ Features

> **Comprehensive coverage of ES2021+ JavaScript features: Promise.any(), Logical Assignment operators, WeakRef, and FinalizationRegistry**

<link rel="stylesheet" href="../common-styles.css">

---

## 📚 Table of Contents

- [ES2021 Overview](#es2021-overview)
- [Promise.any()](#promiseany)
- [Logical Assignment Operators](#logical-assignment-operators)
- [WeakRef](#weakref)
- [FinalizationRegistry](#finalizationregistry)
- [Detailed Examples](#detailed-examples)
- [Common Interview Questions](#common-interview-questions)
- [Practice Exercises](#practice-exercises)
- [Additional Resources](#additional-resources)

---

## 🎯 ES2021 Overview

**ES2021** (ECMAScript 2021) introduced several powerful features that enhance JavaScript's Promise handling, assignment operations, and memory management capabilities.

### Why ES2021+ Features Matter:
- **Better Promise Handling**: Promise.any() for race conditions with fallbacks
- **Cleaner Assignment**: Logical assignment operators for concise code
- **Memory Management**: WeakRef and FinalizationRegistry for advanced memory control
- **Performance**: More efficient operations and better resource management
- **Developer Experience**: Write more expressive and maintainable code

---

## 🏁 Promise.any()

**Promise.any()** takes an iterable of Promise objects and returns a single Promise that fulfills as soon as any of the promises in the iterable fulfills, or rejects if all promises reject.

### Why Promise.any() Matters:
- **Race Conditions**: Handle multiple async operations efficiently
- **Fallback Strategies**: Implement robust error handling
- **Performance**: Get fastest successful result from multiple sources
- **Resilience**: Continue operation even if some promises fail

### ASCII Diagram: Promise.any() Flow
{% raw %}
```
PROMISE.ANY() FLOW
┌─────────────────────────────────┐
│        MULTIPLE PROMISES        │
│  ┌─────────────────────────────┐ │
│  │ Promise A (2s)              │ │
│  │ Promise B (1s) ← FULFILLS   │ │
│  │ Promise C (3s)              │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘
                │
                ▼
        ┌───────────────┐
        │  FIRST        │
        │  SUCCESS      │
        │  Promise B    │
        │  Resolves     │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  RESULT       │
        │  Promise.any()│
        │  Fulfills     │
        │  With B       │
        └───────────────┘
```
{% endraw %}

### Comparison with Other Promise Methods:
{% raw %}
```javascript
// Promise.all() - waits for ALL promises to fulfill
Promise.all([promise1, promise2, promise3])
    .then(results => console.log('All completed:', results))
    .catch(error => console.log('One failed:', error));

// Promise.race() - returns first promise to settle (fulfill OR reject)
Promise.race([promise1, promise2, promise3])
    .then(result => console.log('First to complete:', result))
    .catch(error => console.log('First to fail:', error));

// Promise.any() - returns first promise to fulfill (ignores rejections)
Promise.any([promise1, promise2, promise3])
    .then(result => console.log('First success:', result))
    .catch(error => console.log('All failed:', error));
```
{% endraw %}

---

## 🔀 Logical Assignment Operators

**Logical Assignment Operators** combine logical operations with assignment, providing a concise way to assign values based on conditions.

### Why Logical Assignment Matters:
- **Conciseness**: Reduce code verbosity
- **Readability**: Make intent clearer
- **Performance**: Single operation instead of multiple
- **Consistency**: Follow modern JavaScript patterns

### ASCII Diagram: Logical Assignment Flow
{% raw %}
```
LOGICAL ASSIGNMENT FLOW
┌─────────────────────────────────┐
│        ASSIGNMENT LOGIC         │
│  ┌─────────────────────────────┐ │
│  │ variable ||= value          │ │
│  │                             │ │
│  │ Check: variable is falsy?   │ │
│  │ Yes → assign value          │ │
│  │ No → keep variable          │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘
                │
                ▼
        ┌───────────────┐
        │  CONDITION    │
        │  Check        │
        │  Variable     │
        │  Value        │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  ASSIGNMENT   │
        │  Conditional  │
        │  Assignment   │
        │  Based on     │
        │  Logic        │
        └─────────────┘
```
{% endraw %}

### Available Operators:
1. **Logical OR Assignment (||=)**: Assigns if left operand is falsy
2. **Logical AND Assignment (&&=)**: Assigns if left operand is truthy
3. **Nullish Coalescing Assignment (??=)**: Assigns if left operand is nullish

---

## 🗑️ WeakRef

**WeakRef** creates a weak reference to an object, allowing the object to be garbage collected even if the WeakRef exists.

### Why WeakRef Matters:
- **Memory Management**: Allow objects to be garbage collected
- **Caching**: Implement weak caches that don't prevent cleanup
- **Performance**: Avoid memory leaks in long-running applications
- **Resource Control**: Better control over object lifecycle

### ASCII Diagram: WeakRef Memory Management
{% raw %}
```
WEAKREF MEMORY MANAGEMENT
┌─────────────────────────────────┐
│        OBJECT REFERENCES        │
│  ┌─────────────────────────────┐ │
│  │ const obj = { data: "..." } │ │
│  │ const weakRef = new WeakRef(obj) │ │
│  │                             │ │
│  │ obj = null;                 │ │
│  │ // Object can be GC'd       │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘
                │
                ▼
        ┌───────────────┐
        │  GARBAGE      │
        │  COLLECTION   │
        │  Object       │
        │  Eligible     │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  WEAKREF      │
        │  Doesn't      │
        │  Prevent      │
        │  Cleanup      │
        └───────────────┘
```
{% endraw %}

### Use Cases:
- **Caching**: Store expensive computations without preventing cleanup
- **Event Listeners**: Reference DOM elements without preventing removal
- **Resource Management**: Track resources without blocking disposal
- **Performance Monitoring**: Monitor objects without affecting lifecycle

---

## 🏛️ FinalizationRegistry

**FinalizationRegistry** provides a way to request a callback when an object is garbage collected, useful for cleanup operations.

### Why FinalizationRegistry Matters:
- **Resource Cleanup**: Automatically clean up when objects are destroyed
- **Memory Management**: Track object lifecycle for better resource control
- **Debugging**: Monitor when objects are garbage collected
- **System Integration**: Integrate with external systems that need cleanup

### ASCII Diagram: FinalizationRegistry Flow
{% raw %}
```
FINALIZATIONREGISTRY FLOW
┌─────────────────────────────────┐
│        OBJECT LIFECYCLE         │
│  ┌─────────────────────────────┐ │
│  │ const obj = new MyObject(); │ │
│  │ const registry = new        │ │
│  │   FinalizationRegistry(cleanup); │ │
│  │                             │ │
│  │ registry.register(obj, "key"); │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘
                │
                ▼
        ┌───────────────┐
        │  OBJECT       │
        │  GARBAGE      │
        │  COLLECTED    │
        │  (Eventually) │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  CALLBACK     │
        │  Executed     │
        │  Cleanup      │
        │  Performed    │
        └───────────────┘
```
{% endraw %}

### Use Cases:
- **File Handles**: Close files when objects are destroyed
- **Database Connections**: Close connections automatically
- **External Resources**: Clean up external system resources
- **Memory Monitoring**: Track object lifecycle for debugging

---

## 💻 Detailed Examples

### Example 1: Promise.any() for Multi-Source Data Fetching
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
<pre><code>// Multi-source data fetching with Promise.any()
class MultiSourceDataFetcher {
    constructor() {
        this.sources = [
            { name: 'Primary API', url: 'https://api.primary.com/data', timeout: 3000 },
            { name: 'Backup API', url: 'https://api.backup.com/data', timeout: 2000 },
            { name: 'Cache Server', url: 'https://cache.example.com/data', timeout: 1000 }
        ];
    }
    
    // Fetch from a single source with timeout
    async fetchFromSource(source) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), source.timeout);
        
        try {
            const response = await fetch(source.url, {
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            return { source: source.name, data, timestamp: Date.now() };
        } catch (error) {
            clearTimeout(timeoutId);
            throw new Error(`Failed to fetch from ${source.name}: ${error.message}`);
        }
    }
    
    // Fetch from multiple sources using Promise.any()
    async fetchData() {
        const promises = this.sources.map(source => 
            this.fetchFromSource(source).catch(error => {
                console.warn(`Source ${source.name} failed:`, error.message);
                throw error; // Re-throw to be handled by Promise.any()
            })
        );
        
        try {
            // Get the first successful result
            const result = await Promise.any(promises);
            console.log(`Data fetched from ${result.source} in ${Date.now() - result.timestamp}ms`);
            return result.data;
        } catch (error) {
            // All sources failed
            console.error('All data sources failed:', error.message);
            throw new Error('Unable to fetch data from any source');
        }
    }
    
    // Fetch with fallback strategy
    async fetchWithFallback() {
        try {
            return await this.fetchData();
        } catch (error) {
            console.log('Falling back to cached data...');
            return this.getCachedData();
        }
    }
    
    getCachedData() {
        // Return stale cached data as last resort
        return { message: 'Using cached data', timestamp: Date.now() - 3600000 };
    }
}

// Usage
const fetcher = new MultiSourceDataFetcher();

// Fetch data from fastest available source
fetcher.fetchData()
    .then(data => console.log('Data received:', data))
    .catch(error => console.error('Fetch failed:', error.message));

// Fetch with fallback
fetcher.fetchWithFallback()
    .then(data => console.log('Data with fallback:', data));
</code></pre>
</div>

### Example 2: Logical Assignment Operators in Real Applications
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
<pre><code>// Configuration management with logical assignment
class ConfigurationManager {
    constructor() {
        this.config = {};
    }
    
    // Set default values using logical assignment
    setDefaults() {
        // Logical OR assignment - only assign if falsy
        this.config.port ||= 3000;
        this.config.host ||= 'localhost';
        this.config.debug ||= false;
        
        // Logical AND assignment - only assign if truthy
        this.config.environment &&= this.config.environment.toUpperCase();
        this.config.timeout &&= Math.max(this.config.timeout, 1000);
        
        // Nullish coalescing assignment - only assign if null/undefined
        this.config.retries ??= 3;
        this.config.logLevel ??= 'info';
        this.config.maxConnections ??= 100;
    }
    
    // Update configuration with logical assignment
    updateConfig(newConfig) {
        // Merge new config, using logical assignment for defaults
        Object.entries(newConfig).forEach(([key, value]) => {
            if (key === 'port' || key === 'host') {
                // For critical settings, always update
                this.config[key] = value;
            } else if (key === 'debug') {
                // For boolean flags, only update if not already set
                this.config[key] ||= value;
            } else {
                // For optional settings, use nullish coalescing
                this.config[key] ??= value;
            }
        });
        
        this.setDefaults();
    }
    
    // Get configuration with fallbacks
    getConfig() {
        return { ...this.config };
    }
}

// Usage
const configManager = new ConfigurationManager();

// Set initial defaults
configManager.setDefaults();
console.log('Initial config:', configManager.getConfig());

// Update with partial configuration
configManager.updateConfig({
    port: 8080,
    environment: 'production',
    customSetting: 'value'
});

console.log('Updated config:', configManager.getConfig());

// User preferences with logical assignment
class UserPreferences {
    constructor() {
        this.preferences = {};
    }
    
    // Set preference with logical assignment
    setPreference(key, value) {
        // Only set if not already configured
        this.preferences[key] ||= value;
    }
    
    // Set required preference
    setRequiredPreference(key, value) {
        // Always set required preferences
        this.preferences[key] = value;
    }
    
    // Set preference with nullish coalescing
    setOptionalPreference(key, value) {
        // Only set if not already set (including false/0/"" values)
        this.preferences[key] ??= value;
    }
    
    // Get preference with fallback
    getPreference(key, fallback) {
        return this.preferences[key] ?? fallback;
    }
}

// Usage
const userPrefs = new UserPreferences();

// Set preferences
userPrefs.setPreference('theme', 'dark');           // Will set
userPrefs.setPreference('theme', 'light');          // Won't override
userPrefs.setRequiredPreference('userId', '12345'); // Will always set
userPrefs.setOptionalPreference('notifications', false); // Will set
userPrefs.setOptionalPreference('notifications', true);  // Won't override

console.log('User preferences:', userPrefs.preferences);
</code></pre>
</div>

### Example 3: WeakRef for Memory-Efficient Caching
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
<pre><code>// Memory-efficient cache using WeakRef
class WeakCache {
    constructor() {
        this.cache = new Map();
        this.cleanupInterval = setInterval(() => this.cleanup(), 60000); // Cleanup every minute
    }
    
    // Set cache entry with WeakRef
    set(key, value) {
        this.cache.set(key, new WeakRef(value));
    }
    
    // Get cache entry
    get(key) {
        const weakRef = this.cache.get(key);
        if (!weakRef) return undefined;
        
        const value = weakRef.deref();
        if (value === undefined) {
            // Object was garbage collected, remove from cache
            this.cache.delete(key);
            return undefined;
        }
        
        return value;
    }
    
    // Check if key exists and value is still alive
    has(key) {
        const weakRef = this.cache.get(key);
        if (!weakRef) return false;
        
        const value = weakRef.deref();
        if (value === undefined) {
            this.cache.delete(key);
            return false;
        }
        
        return true;
    }
    
    // Cleanup dead references
    cleanup() {
        for (const [key, weakRef] of this.cache.entries()) {
            if (weakRef.deref() === undefined) {
                this.cache.delete(key);
            }
        }
        
        console.log(`Cache cleanup: ${this.cache.size} entries remaining`);
    }
    
    // Get cache statistics
    getStats() {
        let aliveCount = 0;
        let deadCount = 0;
        
        for (const weakRef of this.cache.values()) {
            if (weakRef.deref() === undefined) {
                deadCount++;
            } else {
                aliveCount++;
            }
        }
        
        return {
            total: this.cache.size,
            alive: aliveCount,
            dead: deadCount
        };
    }
    
    // Destroy cache and cleanup
    destroy() {
        clearInterval(this.cleanupInterval);
        this.cache.clear();
    }
}

// Usage example with DOM elements
class DOMElementCache {
    constructor() {
        this.cache = new WeakCache();
    }
    
    // Cache DOM element
    cacheElement(selector, element) {
        this.cache.set(selector, element);
    }
    
    // Get cached element
    getElement(selector) {
        let element = this.cache.get(selector);
        
        if (!element) {
            // Element not in cache, query DOM
            element = document.querySelector(selector);
            if (element) {
                this.cacheElement(selector, element);
            }
        }
        
        return element;
    }
    
    // Get cache stats
    getStats() {
        return this.cache.getStats();
    }
}

// Usage
const domCache = new DOMElementCache();

// Cache some DOM elements
const header = document.querySelector('header');
const footer = document.querySelector('footer');

if (header) domCache.cacheElement('header', header);
if (footer) domCache.cacheElement('footer', footer);

// Later, get cached elements
const cachedHeader = domCache.getElement('header');
const cachedFooter = domCache.getElement('footer');

console.log('Cache stats:', domCache.getStats());

// Simulate garbage collection (in real scenarios, this happens automatically)
// header = null;
// footer = null;
</code></pre>
</div>

### Example 4: FinalizationRegistry for Resource Cleanup
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
<pre><code>// Resource management with FinalizationRegistry
class ResourceManager {
    constructor() {
        // Create finalization registry for cleanup callbacks
        this.registry = new FinalizationRegistry((heldValue) => {
            console.log(`Resource cleanup triggered for: ${heldValue}`);
            this.cleanupResource(heldValue);
        });
        
        this.resources = new Map();
        this.resourceId = 0;
    }
    
    // Create a resource with automatic cleanup
    createResource(type, data) {
        const id = ++this.resourceId;
        const resource = {
            id,
            type,
            data,
            createdAt: Date.now(),
            isActive: true
        };
        
        // Register with finalization registry
        this.registry.register(resource, `${type}:${id}`);
        
        // Store reference
        this.resources.set(id, resource);
        
        console.log(`Resource created: ${type}:${id}`);
        return resource;
    }
    
    // Cleanup resource when object is garbage collected
    cleanupResource(heldValue) {
        const [type, id] = heldValue.split(':');
        console.log(`Cleaning up ${type} resource ${id}`);
        
        // Perform type-specific cleanup
        switch (type) {
            case 'file':
                this.cleanupFile(id);
                break;
            case 'connection':
                this.cleanupConnection(id);
                break;
            case 'cache':
                this.cleanupCache(id);
                break;
            default:
                console.log(`Unknown resource type: ${type}`);
        }
    }
    
    // Simulate file cleanup
    cleanupFile(id) {
        console.log(`Closing file handle for resource ${id}`);
        // In real implementation: close file descriptor, release locks, etc.
    }
    
    // Simulate connection cleanup
    cleanupConnection(id) {
        console.log(`Closing connection for resource ${id}`);
        // In real implementation: close socket, release port, etc.
    }
    
    // Simulate cache cleanup
    cleanupCache(id) {
        console.log(`Clearing cache for resource ${id}`);
        // In real implementation: clear memory, remove from storage, etc.
    }
    
    // Manually release resource
    releaseResource(id) {
        const resource = this.resources.get(id);
        if (resource) {
            resource.isActive = false;
            this.resources.delete(id);
            
            // Unregister from finalization registry
            this.registry.unregister(resource);
            
            console.log(`Resource ${id} manually released`);
        }
    }
    
    // Get active resources
    getActiveResources() {
        return Array.from(this.resources.values()).filter(r => r.isActive);
    }
    
    // Force cleanup of all resources
    cleanupAll() {
        for (const [id, resource] of this.resources.entries()) {
            this.releaseResource(id);
        }
    }
}

// Usage example
const resourceManager = new ResourceManager();

// Create various resources
const fileResource = resourceManager.createResource('file', { path: '/tmp/data.txt' });
const connectionResource = resourceManager.createResource('connection', { host: 'localhost', port: 8080 });
const cacheResource = resourceManager.createResource('cache', { maxSize: 1000 });

console.log('Active resources:', resourceManager.getActiveResources());

// Manually release one resource
resourceManager.releaseResource(fileResource.id);

// Let others be garbage collected (simulate by removing references)
// fileResource = null;
// connectionResource = null;
// cacheResource = null;

// In real scenarios, when these objects go out of scope or are set to null,
// the FinalizationRegistry will trigger cleanup callbacks

// Force cleanup
setTimeout(() => {
    resourceManager.cleanupAll();
    console.log('All resources cleaned up');
}, 5000);
</code></pre>
</div>

---

## ❓ Common Interview Questions

### Q1: What's the difference between Promise.any() and Promise.race()?
**A:** Promise.any() returns the first promise to fulfill (ignoring rejections), while Promise.race() returns the first promise to settle (either fulfill or reject). Promise.any() is useful when you want the first successful result, while Promise.race() is useful when you want the first completed operation regardless of success or failure.

### Q2: When would you use logical assignment operators?
**A:** Use logical assignment operators when you want to assign values conditionally based on the current state of a variable. ||= is useful for setting defaults, &&= for conditional updates, and ??= for nullish fallbacks. They make code more concise and readable compared to traditional if statements.

### Q3: What are the benefits and risks of using WeakRef?
**A:** WeakRef allows objects to be garbage collected even when referenced, preventing memory leaks. Benefits include memory-efficient caching and resource tracking. Risks include unpredictable cleanup timing (garbage collection is non-deterministic) and potential race conditions if the object is accessed after being collected.

### Q4: How does FinalizationRegistry help with resource management?
**A:** FinalizationRegistry provides a way to automatically clean up resources when objects are garbage collected. This is useful for closing file handles, database connections, or releasing external resources. However, it's not guaranteed to run immediately and should not be relied upon for critical cleanup.

### Q5: What's the performance impact of logical assignment operators?
**A:** Logical assignment operators are generally more performant than equivalent if statements because they're single operations that can be optimized by the JavaScript engine. They reduce code size and improve readability while maintaining the same performance characteristics as the equivalent logical operations.

---

## 🏋️ Practice Exercises

### Exercise 1: Implement a Robust Data Fetcher
Create a data fetcher that uses Promise.any() to fetch from multiple sources with proper error handling, timeouts, and fallback strategies.

### Exercise 2: Build a Memory-Efficient Cache System
Implement a caching system using WeakRef that automatically cleans up unused entries and provides statistics on cache usage.

### Exercise 3: Create a Resource Lifecycle Manager
Build a system using FinalizationRegistry that manages various types of resources (files, connections, caches) with automatic cleanup and monitoring.

---

## 📚 Additional Resources

- **ES2021 Specification**: [ECMAScript 2021](https://tc39.es/ecma262/2021/)
- **Promise.any()**: [MDN Promise.any()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any)
- **Logical Assignment**: [MDN Logical Assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_assignment)
- **WeakRef**: [MDN WeakRef](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef)
- **FinalizationRegistry**: [MDN FinalizationRegistry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry)

---

## 📋 Copy Code Functionality

<script src="../common-scripts.js"></script>

---

## 🧭 Navigation

<div class="navigation">
    <a href="05-ES2020-Features.md" class="nav-link prev">← Previous: ES2020+ Features</a>
    <a href="07-ES2022-Features.md" class="nav-link next">Next: ES2022+ Features →</a>
</div>

*Last updated: December 2024*
