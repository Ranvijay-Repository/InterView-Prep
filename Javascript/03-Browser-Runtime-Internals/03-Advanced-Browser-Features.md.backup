# 🔹 Advanced Browser Features

> **Comprehensive coverage of advanced browser capabilities: WebAssembly basics, WebGL & Canvas optimization, and IndexedDB & advanced storage**

<link rel="stylesheet" href="../common-styles.css">

---

## 📚 Table of Contents

- [Advanced Browser Features Overview](#advanced-browser-features-overview)
- [WebAssembly Basics](#webassembly-basics)
- [WebGL & Canvas Optimization](#webgl--canvas-optimization)
- [IndexedDB & Advanced Storage](#indexeddb--advanced-storage)
- [Detailed Examples](#detailed-examples)
- [Common Interview Questions](#common-interview-questions)
- [Practice Exercises](#practice-exercises)
- [Additional Resources](#additional-resources)

---

## 🎯 Advanced Browser Features Overview

**Advanced Browser Features** provide cutting-edge capabilities for building high-performance web applications with native-like performance, advanced graphics, and sophisticated data storage.

### Why Advanced Browser Features Matter:
- **Performance**: Near-native performance with WebAssembly
- **Graphics**: High-performance 2D/3D rendering with WebGL
- **Storage**: Advanced client-side data management
- **Competitive Edge**: Build applications that outperform competitors
- **Future-Proof**: Use the latest web technologies

---

## ⚡ WebAssembly Basics

**WebAssembly (WASM)** is a binary instruction format that enables near-native performance in web browsers, allowing you to run code written in languages like C++, Rust, and Go.

### Why WebAssembly Matters:
- **Performance**: Near-native execution speed
- **Language Support**: Use multiple programming languages
- **Security**: Sandboxed execution environment
- **Portability**: Run the same code across platforms
- **Integration**: Seamless JavaScript interop

### ASCII Diagram: WebAssembly Execution Flow
{% raw %}
```
WEBASSEMBLY EXECUTION FLOW
┌─────────────────────────────────┐
│        SOURCE CODE              │
│  ┌─────────────────────────────┐ │
│  │ C++/Rust/Go Source          │ │
│  │                             │ │
│  │ // High-performance code    │ │
│  │ // Complex algorithms       │ │
│  │ // Native libraries         │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘
                │
                ▼
        ┌───────────────┐
        │  COMPILATION  │
        │  To WASM      │
        │  Binary       │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  BROWSER      │
        │  WASM Engine  │
        │  Execution    │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  JAVASCRIPT   │
        │  Integration  │
        │  API Calls    │
        └───────────────┘
```
{% endraw %}

### Use Cases:
- **Performance-Critical Code**: Complex algorithms and computations
- **Game Development**: High-performance game engines
- **Image/Video Processing**: Real-time media manipulation
- **Scientific Computing**: Mathematical and scientific applications
- **Legacy Code Integration**: Port existing C++/Rust applications

---

## 🎨 WebGL & Canvas Optimization

**WebGL** provides hardware-accelerated 3D graphics, while **Canvas** offers 2D drawing capabilities. Both can be optimized for maximum performance.

### Why WebGL & Canvas Optimization Matters:
- **Graphics Performance**: Hardware-accelerated rendering
- **User Experience**: Smooth animations and interactions
- **Resource Efficiency**: Optimize memory and GPU usage
- **Scalability**: Handle complex graphics efficiently
- **Cross-Platform**: Consistent graphics across devices

### ASCII Diagram: WebGL Rendering Pipeline
{% raw %}
```
WEBGL RENDERING PIPELINE
┌─────────────────────────────────┐
│        VERTEX DATA              │
│  ┌─────────────────────────────┐ │
│  │ Position, Color, UV         │ │
│  │ Normals, Indices            │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘
                │
                ▼
        ┌───────────────┐
        │  VERTEX       │
        │  SHADER       │
        │  Processing   │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  RASTERIZATION│
        │  & FRAGMENT   │
        │  SHADER       │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  FRAME        │
        │  BUFFER       │
        │  Output       │
        └───────────────┘
```
{% endraw %}

### Optimization Techniques:
- **Batch Rendering**: Group similar draw calls
- **Texture Atlasing**: Combine multiple textures
- **Level of Detail**: Adjust detail based on distance
- **Frustum Culling**: Only render visible objects
- **Shader Optimization**: Efficient shader code

---

## 💾 IndexedDB & Advanced Storage

**IndexedDB** is a low-level, client-side storage system that provides advanced database capabilities for web applications.

### Why IndexedDB Matters:
- **Large Data Storage**: Store significant amounts of data
- **Complex Queries**: Advanced indexing and search capabilities
- **Offline Support**: Work without internet connection
- **Performance**: Fast data access and manipulation
- **Scalability**: Handle growing data requirements

### ASCII Diagram: IndexedDB Architecture
{% raw %}
```
INDEXEDDB ARCHITECTURE
┌─────────────────────────────────┐
│        APPLICATION LAYER        │
│  ┌─────────────────────────────┐ │
│  │ JavaScript API              │ │
│  │ Data Access Logic           │ │
│  │ Business Rules              │ │
│  └─────────────────────────────┘ │
└─────────────────────────────────┘
                │
                ▼
        ┌───────────────┐
        │  INDEXEDDB    │
        │  API          │
        │  Object Store │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  BROWSER      │
        │  STORAGE      │
        │  Engine       │
        └───────────────┘
                │
                ▼
        ┌───────────────┐
        │  DISK         │
        │  STORAGE      │
        │  Persistence  │
        └───────────────┘
```
{% endraw %}

### Storage Features:
- **Object Stores**: Store JavaScript objects
- **Indexes**: Fast data retrieval
- **Transactions**: Data consistency
- **Versioning**: Schema evolution
- **Cursors**: Efficient data iteration

---

## 💻 Detailed Examples

### Example 1: WebAssembly Integration with JavaScript

### Example 2: WebGL & Canvas Optimization System
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
<pre><code>// WebGL optimization system with performance monitoring
class WebGLOptimizer {
    constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
        this.programs = new Map();
        this.textures = new Map();
        this.buffers = new Map();
        this.performanceMetrics = new Map();
        
        if (!this.gl) {
            throw new Error('WebGL not supported');
        }
        
        this.setupWebGL();
        this.setupPerformanceMonitoring();
    }
    
    setupWebGL() {
        // Enable extensions for better performance
        this.gl.getExtension('OES_standard_derivatives');
        this.gl.getExtension('OES_element_index_uint');
        this.gl.getExtension('WEBGL_depth_texture');
        
        // Set initial state
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.CULL_FACE);
        this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
    }
    
    setupPerformanceMonitoring() {
        // Monitor frame rate and rendering performance
        this.frameCount = 0;
        this.lastTime = performance.now();
        this.fps = 0;
        
        this.monitorPerformance();
    }
    
    monitorPerformance() {
        const currentTime = performance.now();
        this.frameCount++;
        
        if (currentTime - this.lastTime >= 1000) {
            this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
            this.lastTime = currentTime;
            this.frameCount = 0;
            
            // Store performance metrics
            this.performanceMetrics.set('fps', this.fps);
            this.performanceMetrics.set('drawCalls', this.drawCalls || 0);
            this.performanceMetrics.set('triangles', this.triangles || 0);
            
            // Reset counters
            this.drawCalls = 0;
            this.triangles = 0;
        }
        
        requestAnimationFrame(() => this.monitorPerformance());
    }
    
    // Create optimized shader program
    createProgram(vertexShader, fragmentShader) {
        const program = this.gl.createProgram();
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);
        
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            console.error('Program link error:', this.gl.getProgramInfoLog(program));
            return null;
        }
        
        return program;
    }
    
    // Batch rendering for multiple objects
    batchRender(objects, program, attributes) {
        if (objects.length === 0) return;
        
        performance.mark('batch-render-start');
        
        // Use single draw call for multiple objects
        this.gl.useProgram(program);
        
        // Set common attributes
        Object.entries(attributes).forEach(([name, value]) => {
            const location = this.gl.getUniformLocation(program, name);
            if (location) {
                if (Array.isArray(value)) {
                    this.gl.uniformMatrix4fv(location, false, value);
                } else {
                    this.gl.uniform1f(location, value);
                }
            }
        });
        
        // Render all objects in single batch
        this.gl.drawArraysInstanced(
            this.gl.TRIANGLES,
            0,
            objects[0].vertexCount,
            objects.length
        );
        
        this.drawCalls++;
        this.triangles += objects.length * objects[0].vertexCount / 3;
        
        performance.mark('batch-render-end');
        performance.measure('batch-render', 'batch-render-start', 'batch-render-end');
    }
    
    // Texture optimization with atlasing
    createTextureAtlas(textures, atlasSize = 1024) {
        const canvas = document.createElement('canvas');
        canvas.width = atlasSize;
        canvas.height = atlasSize;
        const ctx = canvas.getContext('2d');
        
        const atlas = this.gl.createTexture();
        this.gl.bindTexture(this.gl.TEXTURE_2D, atlas);
        
        // Pack textures into atlas
        let x = 0, y = 0, maxHeight = 0;
        const textureCoords = new Map();
        
        textures.forEach((texture, name) => {
            if (x + texture.width > atlasSize) {
                x = 0;
                y += maxHeight;
                maxHeight = 0;
            }
            
            // Draw texture to atlas
            ctx.drawImage(texture, x, y);
            
            // Store texture coordinates
            textureCoords.set(name, {
                x: x / atlasSize,
                y: y / atlasSize,
                width: texture.width / atlasSize,
                height: texture.height / atlasSize
            });
            
            x += texture.width;
            maxHeight = Math.max(maxHeight, texture.height);
        });
        
        // Upload atlas to GPU
        this.gl.texImage2D(
            this.gl.TEXTURE_2D,
            0,
            this.gl.RGBA,
            this.gl.RGBA,
            this.gl.UNSIGNED_BYTE,
            canvas
        );
        
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        
        return { atlas, textureCoords };
    }
    
    // Frustum culling for performance
    isInFrustum(object, frustum) {
        const { position, boundingBox } = object;
        
        // Check if object bounding box intersects with view frustum
        for (let i = 0; i < 6; i++) {
            const plane = frustum[i];
            const distance = plane.distanceToPoint(position);
            
            if (distance < -boundingBox.radius) {
                return false; // Object is outside frustum
            }
        }
        
        return true;
    }
    
    // Level of detail system
    getLODLevel(distance, maxDistance) {
        const ratio = distance / maxDistance;
        
        if (ratio < 0.3) return 'high';
        if (ratio < 0.7) return 'medium';
        return 'low';
    }
    
    // Get performance metrics
    getPerformanceMetrics() {
        return Object.fromEntries(this.performanceMetrics);
    }
    
    // Cleanup resources
    cleanup() {
        // Delete programs
        this.programs.forEach(program => {
            this.gl.deleteProgram(program);
        });
        
        // Delete textures
        this.textures.forEach(texture => {
            this.gl.deleteTexture(texture);
        });
        
        // Delete buffers
        this.buffers.forEach(buffer => {
            this.gl.deleteBuffer(buffer);
        });
        
        this.programs.clear();
        this.textures.clear();
        this.buffers.clear();
    }
}

// Usage example
const canvas = document.getElementById('webgl-canvas');
const webglOptimizer = new WebGLOptimizer(canvas);

// Get performance metrics
setInterval(() => {
    const metrics = webglOptimizer.getPerformanceMetrics();
    console.log('WebGL Performance:', metrics);
}, 1000);
</code></pre>
</div>

### Example 3: IndexedDB Advanced Storage System
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
<pre><code>// Advanced IndexedDB storage system with performance optimization
class IndexedDBManager {
    constructor(dbName, version = 1) {
        this.dbName = dbName;
        this.version = version;
        this.db = null;
        this.stores = new Map();
        this.performanceMetrics = new Map();
    }
    
    // Initialize database
    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);
            
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };
            
            request.onupgradeneeded = (event) => {
                this.handleUpgrade(event);
            };
        });
    }
    
    // Handle database upgrade
    handleUpgrade(event) {
        const db = event.target.result;
        
        // Create object stores
        if (!db.objectStoreNames.contains('users')) {
            const userStore = db.createObjectStore('users', { keyPath: 'id', autoIncrement: true });
            userStore.createIndex('email', 'email', { unique: true });
            userStore.createIndex('name', 'name');
            userStore.createIndex('createdAt', 'createdAt');
        }
        
        if (!db.objectStoreNames.contains('products')) {
            const productStore = db.createObjectStore('products', { keyPath: 'id' });
            productStore.createIndex('category', 'category');
            productStore.createIndex('price', 'price');
            productStore.createIndex('tags', 'tags', { multiEntry: true });
        }
        
        if (!db.objectStoreNames.contains('orders')) {
            const orderStore = db.createObjectStore('orders', { keyPath: 'id', autoIncrement: true });
            orderStore.createIndex('userId', 'userId');
            orderStore.createIndex('status', 'status');
            orderStore.createIndex('createdAt', 'createdAt');
        }
    }
    
    // Add data with performance tracking
    async add(storeName, data) {
        performance.mark(`indexeddb-add-start-${storeName}`);
        
        try {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            const request = store.add(data);
            
            return new Promise((resolve, reject) => {
                request.onsuccess = () => {
                    performance.mark(`indexeddb-add-end-${storeName}`);
                    performance.measure(
                        `indexeddb-add-${storeName}`,
                        `indexeddb-add-start-${storeName}`,
                        `indexeddb-add-end-${storeName}`
                    );
                    resolve(request.result);
                };
                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error(`Error adding to ${storeName}:`, error);
            throw error;
        }
    }
    
    // Get data with advanced querying
    async get(storeName, key) {
        const transaction = this.db.transaction([storeName], 'readonly');
        const store = transaction.objectStore(storeName);
        const request = store.get(key);
        
        return new Promise((resolve, reject) => {
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }
    
    // Query data with indexes
    async query(storeName, indexName, value, range = null) {
        performance.mark(`indexeddb-query-start-${storeName}-${indexName}`);
        
        try {
            const transaction = this.db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const index = store.index(indexName);
            
            let request;
            if (range) {
                request = index.openCursor(range);
            } else {
                request = index.getAll(value);
            }
            
            return new Promise((resolve, reject) => {
                if (range) {
                    const results = [];
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            results.push(cursor.value);
                            cursor.continue();
                        } else {
                            performance.mark(`indexeddb-query-end-${storeName}-${indexName}`);
                            performance.measure(
                                `indexeddb-query-${storeName}-${indexName}`,
                                `indexeddb-query-start-${storeName}-${indexName}`,
                                `indexeddb-query-end-${storeName}-${indexName}`
                            );
                            resolve(results);
                        }
                    };
                } else {
                    request.onsuccess = () => {
                        performance.mark(`indexeddb-query-end-${storeName}-${indexName}`);
                        performance.measure(
                            `indexeddb-query-${storeName}-${indexName}`,
                            `indexeddb-query-start-${storeName}-${indexName}`,
                            `indexeddb-query-end-${storeName}-${indexName}`
                        );
                        resolve(request.result);
                    };
                }
                request.onerror = () => reject(request.error);
            });
        } catch (error) {
            console.error(`Error querying ${storeName}:`, error);
            throw error;
        }
    }
    
    // Batch operations for performance
    async batchAdd(storeName, items) {
        performance.mark(`indexeddb-batch-start-${storeName}`);
        
        try {
            const transaction = this.db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            
            const promises = items.map(item => {
                return new Promise((resolve, reject) => {
                    const request = store.add(item);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            });
            
            const results = await Promise.all(promises);
            
            performance.mark(`indexeddb-batch-end-${storeName}`);
            performance.measure(
                `indexeddb-batch-${storeName}`,
                `indexeddb-batch-start-${storeName}`,
                `indexeddb-batch-end-${storeName}`
            );
            
            return results;
        } catch (error) {
            console.error(`Error in batch add to ${storeName}:`, error);
            throw error;
        }
    }
    
    // Advanced search with multiple criteria
    async advancedSearch(storeName, criteria) {
        const transaction = this.db.transaction([storeName], 'readonly');
        const store = transaction.objectStore(storeName);
        
        return new Promise((resolve, reject) => {
            const request = store.openCursor();
            const results = [];
            
            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    const item = cursor.value;
                    
                    // Check if item matches all criteria
                    const matches = Object.entries(criteria).every(([key, value]) => {
                        if (Array.isArray(value)) {
                            return value.includes(item[key]);
                        }
                        return item[key] === value;
                    });
                    
                    if (matches) {
                        results.push(item);
                    }
                    
                    cursor.continue();
                } else {
                    resolve(results);
                }
            };
            
            request.onerror = () => reject(request.error);
        });
    }
    
    // Get performance metrics
    getPerformanceMetrics() {
        return Object.fromEntries(this.performanceMetrics);
    }
    
    // Clear performance metrics
    clearPerformanceMetrics() {
        this.performanceMetrics.clear();
    }
    
    // Close database
    close() {
        if (this.db) {
            this.db.close();
        }
    }
}

// Usage example
const dbManager = new IndexedDBManager('MyApp', 1);

// Initialize database
dbManager.init().then(() => {
    console.log('IndexedDB initialized successfully');
    
    // Add sample data
    const users = [
        { name: 'John Doe', email: 'john@example.com', createdAt: new Date() },
        { name: 'Jane Smith', email: 'jane@example.com', createdAt: new Date() }
    ];
    
    return dbManager.batchAdd('users', users);
}).then(() => {
    // Query users by email
    return dbManager.query('users', 'email', 'john@example.com');
}).then(users => {
    console.log('Found users:', users);
    
    // Get performance metrics
    const metrics = dbManager.getPerformanceMetrics();
    console.log('IndexedDB Performance:', metrics);
}).catch(error => {
    console.error('Database error:', error);
});
</code></pre>
</div>

---

## ❓ Common Interview Questions

### Q1: What are the main benefits of WebAssembly over traditional JavaScript?
**A:** WebAssembly provides near-native performance, supports multiple programming languages (C++, Rust, Go), offers better security through sandboxed execution, enables porting of existing native libraries, and provides predictable performance characteristics for performance-critical applications.

### Q2: How can you optimize WebGL performance in a web application?
**A:** WebGL optimization techniques include batch rendering to reduce draw calls, texture atlasing to minimize texture switches, frustum culling to only render visible objects, level of detail systems, efficient shader programs, and proper resource management with cleanup.

### Q3: What are the advantages of IndexedDB over localStorage?
**A:** IndexedDB supports much larger data storage, provides complex querying with indexes, supports transactions for data consistency, handles structured data better, offers better performance for large datasets, and supports offline-first applications with sophisticated data management.

### Q4: How does WebAssembly handle memory management?
**A:** WebAssembly uses a linear memory model with a contiguous array of bytes, provides memory.grow() for dynamic allocation, allows JavaScript to access WASM memory through ArrayBuffer views, and requires careful memory management to prevent memory leaks and ensure optimal performance.

### Q5: What are the key considerations when implementing a WebGL application?
**A:** Key considerations include device capability detection, fallback rendering for unsupported devices, efficient resource management, proper error handling, performance monitoring, responsive design for different screen sizes, and graceful degradation for older browsers.

---

## 🏋️ Practice Exercises

### Exercise 1: Build a WebAssembly Performance Benchmarking Tool
Create a system that compares JavaScript vs WebAssembly performance for mathematical operations, image processing, or other compute-intensive tasks, with detailed performance metrics and visualization.

### Exercise 2: Implement a WebGL Scene Graph with Optimization
Build a 3D scene rendering system using WebGL with features like frustum culling, level of detail, texture atlasing, and performance monitoring to handle complex 3D scenes efficiently.

### Exercise 3: Create an Advanced IndexedDB Application
Build a comprehensive data management application using IndexedDB with features like complex queries, batch operations, offline support, data synchronization, and performance optimization.

---

## 📚 Additional Resources

- **WebAssembly**: [MDN WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)
- **WebGL**: [MDN WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API)
- **Canvas**: [MDN Canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)
- **IndexedDB**: [MDN IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
- **Web Performance**: [Web.dev Performance](https://web.dev/performance/)

---

## 📋 Copy Code Functionality
<div style="position: relative;">
<button onclick="copyCode(this)" class="copy-btn">📋 Copy</button>
<pre><code>// WebAssembly integration system
class WebAssemblyManager {
    constructor() {
        this.modules = new Map();
        this.instances = new Map();
        this.performanceMetrics = new Map();
    }
    
    // Load WebAssembly module
    async loadModule(name, wasmPath, importObject = {}) {
        try {
            performance.mark(`wasm-load-start-${name}`);
            
            // Fetch WebAssembly binary
            const response = await fetch(wasmPath);
            const wasmBuffer = await response.arrayBuffer();
            
            // Compile WebAssembly module
            const module = await WebAssembly.compile(wasmBuffer);
            
            // Instantiate module
            const instance = await WebAssembly.instantiate(module, importObject);
            
            // Store module and instance
            this.modules.set(name, module);
            this.instances.set(name, instance);
            
            performance.mark(`wasm-load-end-${name}`);
            performance.measure(
                `wasm-load-${name}`,
                `wasm-load-start-${name}`,
                `wasm-load-end-${name}`
            );
            
            console.log(`WebAssembly module '${name}' loaded successfully`);
            return instance;
            
        } catch (error) {
            console.error(`Failed to load WebAssembly module '${name}':`, error);
            throw error;
        }
    }
    
    // Execute WebAssembly function with performance tracking
    executeFunction(moduleName, functionName, ...args) {
        const instance = this.instances.get(moduleName);
        if (!instance) {
            throw new Error(`Module '${moduleName}' not loaded`);
        }
        
        const wasmFunction = instance.exports[functionName];
        if (!wasmFunction) {
            throw new Error(`Function '${functionName}' not found in module '${moduleName}'`);
        }
        
        performance.mark(`wasm-exec-start-${moduleName}-${functionName}`);
        
        try {
            const result = wasmFunction(...args);
            
            performance.mark(`wasm-exec-end-${moduleName}-${functionName}`);
            performance.measure(
                `wasm-exec-${moduleName}-${functionName}`,
                `wasm-exec-start-${moduleName}-${functionName}`,
                `wasm-exec-end-${moduleName}-${functionName}`
            );
            
            return result;
        } catch (error) {
            console.error(`WebAssembly execution error:`, error);
            throw error;
        }
    }
    
    // Get performance metrics
    getPerformanceMetrics() {
        const metrics = {};
        for (const [name, value] of this.performanceMetrics) {
            metrics[name] = value;
        }
        return metrics;
    }
    
    // Memory management
    getMemoryInfo(moduleName) {
        const instance = this.instances.get(moduleName);
        if (!instance || !instance.exports.memory) return null;
        
        const memory = instance.exports.memory;
        return {
            buffer: memory.buffer,
            byteLength: memory.buffer.byteLength,
            used: this.getMemoryUsage(memory)
        };
    }
    
    getMemoryUsage(memory) {
        // Estimate memory usage by checking buffer contents
        const buffer = memory.buffer;
        let used = 0;
        const view = new Uint8Array(buffer);
        
        for (let i = 0; i < view.length; i++) {
            if (view[i] !== 0) {
                used = i + 1;
            }
        }
        
        return used;
    }
}

// Usage example
const wasmManager = new WebAssemblyManager();

// Load a WebAssembly module (example path)
// wasmManager.loadModule('math', '/wasm/math.wasm', {
//     env: {
//         memory: new WebAssembly.Memory({ initial: 256 }),
//         console: {
//             log: console.log
//         }
// }).then(() => {
//     // Execute WebAssembly functions
//     const result = wasmManager.executeFunction('math', 'add', 5, 3);
//     console.log('WASM result:', result);
// });
</code></pre>
</div>

---

## 📋 Copy Code Functionality

<script src="../common-scripts.js"></script>

---

## 🧭 Navigation

<div class="navigation">
    <a href="02-Web-APIs-Performance.md" class="nav-link prev">← Previous: Web APIs & Performance</a>
    <a href="01-DOM-Events-Advanced.md" class="nav-link next">Next: Back to Advanced DOM & Events →</a>
</div>

*Last updated: December 2024*
