# 🔍 **Type Testing & Validation**

> **Complete guide to testing TypeScript types, runtime validation, and ensuring type safety in production**

<link rel="stylesheet" href="../../common-styles.css">

---

## 📚 **Table of Contents**

- [Type Testing Overview](#type-testing-overview)
- [Compile-Time Type Testing](#compile-time-type-testing)
- [Runtime Type Validation](#runtime-type-validation)
- [Schema Validation](#schema-validation)
- [Type Guards and Assertions](#type-guards-and-assertions)
- [Advanced Type Testing](#advanced-type-testing)
- [Best Practices](#best-practices)
- [Common Interview Questions](#common-interview-questions)

---

## 🎯 **Type Testing Overview**

Type testing ensures that TypeScript types work correctly at both compile-time and runtime.

### **Type Testing Categories**

{% raw %}
```typescript
// Type testing categories
const typeTestingCategories = {
  compileTime: "Testing types during compilation",
  runtime: "Testing types at runtime",
  schema: "Validating data against schemas",
  guards: "Type guards and assertions"
};

// Benefits of type testing
const benefits = {
  typeSafety: "Ensure types work as expected",
  documentation: "Types serve as documentation",
  refactoring: "Safe refactoring with type changes",
  validation: "Runtime data validation"
};
```
{% endraw %}

### **Type Testing Tools**

{% raw %}
```typescript
// Popular type testing tools
const typeTestingTools = {
  dtslint: "TypeScript definition testing",
  tsd: "TypeScript definition testing",
  zod: "Runtime schema validation",
  io-ts: "Runtime type validation",
  yup: "Schema validation",
  joi: "Schema validation"
};
```
{% endraw %}

---

## 🔧 **Compile-Time Type Testing**

### **Type Definition Testing**

{% raw %}
```typescript
// type-tests.ts
import { expectType, expectError } from 'tsd';

// Test successful type inference
expectType<string>('hello');
expectType<number>(42);
expectType<boolean>(true);

// Test function return types
function add(a: number, b: number): number {
  return a + b;
}

expectType<number>(add(1, 2));

// Test generic types
function identity<T>(value: T): T {
  return value;
}

expectType<string>(identity('hello'));
expectType<number>(identity(42));

// Test error cases
expectError(identity('hello')); // Should error if type doesn't match
expectError(add('1', 2)); // Should error with wrong argument types
```
{% endraw %}

### **Advanced Type Testing**

{% raw %}
```typescript
// advanced-type-tests.ts
import { expectType, expectError } from 'tsd';

// Test utility types
type User = {
  id: number;
  name: string;
  email: string;
};

type PartialUser = Partial<User>;
expectType<PartialUser>({ name: 'John' });

type RequiredUser = Required<User>;
expectType<RequiredUser>({ id: 1, name: 'John', email: 'john@example.com' });

// Test conditional types
type IsString<T> = T extends string ? true : false;
expectType<true>({} as IsString<string>);
expectType<false>({} as IsString<number>);

// Test mapped types
type ReadonlyUser = {
  readonly [K in keyof User]: User[K];
};
expectType<ReadonlyUser>({ id: 1, name: 'John', email: 'john@example.com' });

// Test template literal types
type EventName<T extends string> = `on${Capitalize<T>}`;
expectType<'onClick'>({} as EventName<'click'>);
expectType<'onSubmit'>({} as EventName<'submit'>);
```
{% endraw %}

### **Type Definition Testing with dtslint**

{% raw %}
```typescript
// types/__tests__/my-library.test.ts
import { expectType, expectError } from 'tsd';
import { MyLibrary } from '../index';

// Test exported types
expectType<MyLibrary>(new MyLibrary());

// Test method signatures
const lib = new MyLibrary();
expectType<Promise<string>>(lib.fetchData());
expectType<void>(lib.setConfig({ apiUrl: 'https://api.example.com' }));

// Test error cases
expectError(lib.setConfig('invalid')); // Should error with wrong type
expectError(lib.fetchData('extra-arg')); // Should error with extra arguments
```
{% endraw %}

---

## 🛡️ **Runtime Type Validation**

### **Basic Runtime Validation**

{% raw %}
```typescript
// runtime-validation.ts
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// Basic type checking functions
const isString = (value: unknown): value is string => {
  return typeof value === 'string';
};

const isNumber = (value: unknown): value is number => {
  return typeof value === 'number' && !isNaN(value);
};

const isObject = (value: unknown): value is Record<string, unknown> => {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
};

// User validation
const isValidUser = (value: unknown): value is User => {
  if (!isObject(value)) return false;
  
  return (
    isNumber(value.id) &&
    isString(value.name) &&
    isString(value.email) &&
    isNumber(value.age)
  );
};

// Usage
const validateUser = (data: unknown): User => {
  if (isValidUser(data)) {
    return data;
  }
  throw new Error('Invalid user data');
};

// Test
try {
  const user = validateUser({ id: 1, name: 'John', email: 'john@example.com', age: 30 });
  console.log('Valid user:', user);
} catch (error) {
  console.error('Validation error:', error);
}
```
{% endraw %}

### **Advanced Runtime Validation**

{% raw %}
```typescript
// advanced-runtime-validation.ts
interface ValidationResult<T> {
  success: true;
  data: T;
} | {
  success: false;
  errors: string[];
};

class TypeValidator {
  private errors: string[] = [];

  validate<T>(value: unknown, validator: (val: unknown) => val is T): ValidationResult<T> {
    this.errors = [];
    
    if (validator(value)) {
      return { success: true, data: value };
    }
    
    return { success: false, errors: this.errors };
  }

  addError(message: string): void {
    this.errors.push(message);
  }

  // String validators
  string(value: unknown): value is string {
    if (typeof value !== 'string') {
      this.addError('Expected string');
      return false;
    }
    return true;
  }

  stringMinLength(minLength: number) {
    return (value: unknown): value is string => {
      if (!this.string(value)) return false;
      if (value.length < minLength) {
        this.addError(`String must be at least ${minLength} characters`);
        return false;
      }
      return true;
    };
  }

  email(value: unknown): value is string {
    if (!this.string(value)) return false;
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(value)) {
      this.addError('Invalid email format');
      return false;
    }
    return true;
  }

  // Number validators
  number(value: unknown): value is number {
    if (typeof value !== 'number' || isNaN(value)) {
      this.addError('Expected number');
      return false;
    }
    return true;
  }

  numberRange(min: number, max: number) {
    return (value: unknown): value is number => {
      if (!this.number(value)) return false;
      if (value < min || value > max) {
        this.addError(`Number must be between ${min} and ${max}`);
        return false;
      }
      return true;
    };
  }

  // Object validators
  object<T>(shape: Record<string, (val: unknown) => boolean>) {
    return (value: unknown): value is T => {
      if (typeof value !== 'object' || value === null || Array.isArray(value)) {
        this.addError('Expected object');
        return false;
      }

      const obj = value as Record<string, unknown>;
      for (const [key, validator] of Object.entries(shape)) {
        if (!validator(obj[key])) {
          this.addError(`Invalid property: ${key}`);
          return false;
        }
      }

      return true;
    };
  }
}

// Usage
const validator = new TypeValidator();

const userValidator = validator.object<User>({
  id: validator.number,
  name: validator.stringMinLength(2),
  email: validator.email,
  age: validator.numberRange(18, 120)
});

const result = validator.validate(userData, userValidator);
if (result.success) {
  console.log('Valid user:', result.data);
} else {
  console.error('Validation errors:', result.errors);
}
```
{% endraw %}

---

## 📋 **Schema Validation**

### **Zod Schema Validation**

{% raw %}
```typescript
// zod-validation.ts
import { z } from 'zod';

// Basic schema
const UserSchema = z.object({
  id: z.number(),
  name: z.string().min(2),
  email: z.string().email(),
  age: z.number().min(18).max(120),
  createdAt: z.date().optional(),
});

// Infer TypeScript type from schema
type User = z.infer<typeof UserSchema>;

// Validation functions
const validateUser = (data: unknown): User => {
  return UserSchema.parse(data);
};

const safeValidateUser = (data: unknown) => {
  return UserSchema.safeParse(data);
};

// Usage
try {
  const user = validateUser({
    id: 1,
    name: 'John Doe',
    email: 'john@example.com',
    age: 30
  });
  console.log('Valid user:', user);
} catch (error) {
  console.error('Validation error:', error);
}

// Safe validation
const result = safeValidateUser(invalidData);
if (result.success) {
  console.log('Valid user:', result.data);
} else {
  console.error('Validation errors:', result.error.errors);
}
```
{% endraw %}

### **Advanced Zod Schemas**

{% raw %}
```typescript
// advanced-zod-schemas.ts
import { z } from 'zod';

// Union types
const StatusSchema = z.enum(['pending', 'approved', 'rejected']);
type Status = z.infer<typeof StatusSchema>;

// Discriminated unions
const EventSchema = z.discriminatedUnion('type', [
  z.object({
    type: z.literal('user_created'),
    userId: z.number(),
    timestamp: z.date(),
  }),
  z.object({
    type: z.literal('user_updated'),
    userId: z.number(),
    changes: z.record(z.unknown()),
    timestamp: z.date(),
  }),
  z.object({
    type: z.literal('user_deleted'),
    userId: z.number(),
    timestamp: z.date(),
  }),
]);

type Event = z.infer<typeof EventSchema>;

// Custom validators
const PasswordSchema = z.string()
  .min(8, 'Password must be at least 8 characters')
  .regex(/[A-Z]/, 'Password must contain uppercase letter')
  .regex(/[a-z]/, 'Password must contain lowercase letter')
  .regex(/\d/, 'Password must contain number')
  .regex(/[!@#$%^&*(),.?":{}|<>]/, 'Password must contain special character');

// Transform and refine
const UserSchema = z.object({
  id: z.number(),
  name: z.string().transform(name => name.trim()),
  email: z.string().email().transform(email => email.toLowerCase()),
  age: z.number().refine(age => age >= 18, 'Must be at least 18 years old'),
  password: PasswordSchema,
}).refine(data => data.name.length > 0, 'Name cannot be empty');

// Partial and pick
const CreateUserSchema = UserSchema.omit({ id: true });
const UpdateUserSchema = UserSchema.partial().omit({ id: true });

// Array validation
const UserListSchema = z.array(UserSchema);
const PaginatedUsersSchema = z.object({
  users: UserListSchema,
  total: z.number(),
  page: z.number(),
  limit: z.number(),
});

// Usage
const createUser = (data: unknown) => {
  return CreateUserSchema.parse(data);
};

const updateUser = (data: unknown) => {
  return UpdateUserSchema.parse(data);
};

const validateUserList = (data: unknown) => {
  return UserListSchema.parse(data);
};
```
{% endraw %}

### **io-ts Runtime Validation**

{% raw %}
```typescript
// io-ts-validation.ts
import * as t from 'io-ts';
import { isRight } from 'fp-ts/Either';

// Basic types
const UserCodec = t.type({
  id: t.number,
  name: t.string,
  email: t.string,
  age: t.number,
});

// Infer TypeScript type
type User = t.TypeOf<typeof UserCodec>;

// Validation
const validateUser = (data: unknown): User => {
  const result = UserCodec.decode(data);
  if (isRight(result)) {
    return result.right;
  }
  throw new Error('Invalid user data');
};

// Safe validation
const safeValidateUser = (data: unknown) => {
  return UserCodec.decode(data);
};

// Usage
const result = safeValidateUser(userData);
if (isRight(result)) {
  console.log('Valid user:', result.right);
} else {
  console.error('Validation errors:', result.left);
}
```
{% endraw %}

---

## 🔒 **Type Guards and Assertions**

### **Basic Type Guards**

{% raw %}
```typescript
// type-guards.ts
interface User {
  id: number;
  name: string;
  email: string;
}

interface Admin {
  id: number;
  name: string;
  email: string;
  permissions: string[];
}

// Type guard functions
const isUser = (value: unknown): value is User => {
  return (
    typeof value === 'object' &&
    value !== null &&
    'id' in value &&
    'name' in value &&
    'email' in value &&
    typeof (value as any).id === 'number' &&
    typeof (value as any).name === 'string' &&
    typeof (value as any).email === 'string'
  );
};

const isAdmin = (value: unknown): value is Admin => {
  return (
    isUser(value) &&
    'permissions' in value &&
    Array.isArray((value as any).permissions)
  );
};

// Usage
const processUser = (data: unknown) => {
  if (isUser(data)) {
    // TypeScript knows data is User here
    console.log(`User: ${data.name} (${data.email})`);
  } else if (isAdmin(data)) {
    // TypeScript knows data is Admin here
    console.log(`Admin: ${data.name} with ${data.permissions.length} permissions`);
  } else {
    throw new Error('Invalid user data');
  }
};
```
{% endraw %}

### **Advanced Type Guards**

{% raw %}
```typescript
// advanced-type-guards.ts
interface ApiResponse<T> {
  success: true;
  data: T;
} | {
  success: false;
  error: string;
};

// Generic type guard
const isApiResponse = <T>(value: unknown): value is ApiResponse<T> => {
  return (
    typeof value === 'object' &&
    value !== null &&
    'success' in value &&
    typeof (value as any).success === 'boolean'
  );
};

// Success response type guard
const isSuccessResponse = <T>(response: ApiResponse<T>): response is { success: true; data: T } => {
  return response.success === true;
};

// Error response type guard
const isErrorResponse = <T>(response: ApiResponse<T>): response is { success: false; error: string } => {
  return response.success === false;
};

// Usage
const handleApiResponse = <T>(response: unknown) => {
  if (isApiResponse<T>(response)) {
    if (isSuccessResponse(response)) {
      // TypeScript knows response.data exists
      console.log('Success:', response.data);
    } else if (isErrorResponse(response)) {
      // TypeScript knows response.error exists
      console.error('Error:', response.error);
    }
  } else {
    throw new Error('Invalid API response format');
  }
};
```
{% endraw %}

### **Type Assertions**

{% raw %}
```typescript
// type-assertions.ts
interface User {
  id: number;
  name: string;
  email: string;
}

// Type assertion function
const assertIsUser = (value: unknown): asserts value is User => {
  if (!isUser(value)) {
    throw new Error('Value is not a valid User');
  }
};

// Usage
const processUserData = (data: unknown) => {
  assertIsUser(data);
  // TypeScript knows data is User here
  console.log(`Processing user: ${data.name}`);
};

// Custom assertion with validation
const assertIsValidUser = (value: unknown): asserts value is User => {
  if (!isUser(value)) {
    throw new Error('Value is not a valid User');
  }
  
  if (value.name.length === 0) {
    throw new Error('User name cannot be empty');
  }
  
  if (!value.email.includes('@')) {
    throw new Error('User email must be valid');
  }
};
```
{% endraw %}

---

## 🚀 **Advanced Type Testing**

### **Type-Level Testing**

{% raw %}
```typescript
// type-level-tests.ts
import { expectType, expectError } from 'tsd';

// Test utility types
type TestUtilityTypes = {
  // Test Partial
  partial: Partial<{ a: number; b: string }>;
  // Test Required
  required: Required<{ a?: number; b?: string }>;
  // Test Pick
  picked: Pick<{ a: number; b: string; c: boolean }, 'a' | 'b'>;
  // Test Omit
  omitted: Omit<{ a: number; b: string; c: boolean }, 'c'>;
  // Test Record
  record: Record<string, number>;
  // Test Exclude
  excluded: Exclude<'a' | 'b' | 'c', 'b'>;
  // Test Extract
  extracted: Extract<'a' | 'b' | 'c', 'a' | 'b'>;
};

// Test conditional types
type TestConditionalTypes = {
  // Test conditional type
  isString: string extends string ? true : false;
  isNumber: number extends string ? true : false;
  // Test infer
  inferArray: string[] extends (infer T)[] ? T : never;
  // Test distributive conditional types
  distributive: 'a' | 'b' extends string ? true : false;
};

// Test mapped types
type TestMappedTypes = {
  // Test mapped type
  readonly: { readonly [K in keyof { a: number; b: string }]: { a: number; b: string }[K] };
  // Test key remapping
  prefixed: { [K in keyof { a: number; b: string } as `get${Capitalize<K>}`]: () => { a: number; b: string }[K] };
  // Test conditional mapped types
  conditional: { [K in keyof { a: number; b: string; c: boolean }]: { a: number; b: string; c: boolean }[K] extends string ? true : false };
};

// Test template literal types
type TestTemplateLiterals = {
  // Test template literals
  event: `on${Capitalize<'click'>}`;
  // Test template literal inference
  inferTemplate: `on${infer T}` extends `on${string}` ? T : never;
  // Test template literal unions
  union: `on${'click' | 'submit' | 'change'}`;
};
```
{% endraw %}

### **Runtime Type Testing**

{% raw %}
```typescript
// runtime-type-tests.ts
import { z } from 'zod';

// Test schema validation
const TestSchema = z.object({
  id: z.number(),
  name: z.string(),
  email: z.string().email(),
});

// Test valid data
const validData = { id: 1, name: 'John', email: 'john@example.com' };
const validResult = TestSchema.safeParse(validData);
console.assert(validResult.success, 'Valid data should pass validation');

// Test invalid data
const invalidData = { id: '1', name: 'John', email: 'invalid-email' };
const invalidResult = TestSchema.safeParse(invalidData);
console.assert(!invalidResult.success, 'Invalid data should fail validation');

// Test type inference
type InferredType = z.infer<typeof TestSchema>;
const testType: InferredType = { id: 1, name: 'John', email: 'john@example.com' };

// Test runtime type checking
const isTestType = (value: unknown): value is InferredType => {
  return TestSchema.safeParse(value).success;
};

console.assert(isTestType(validData), 'Valid data should pass type check');
console.assert(!isTestType(invalidData), 'Invalid data should fail type check');
```
{% endraw %}

---

## ✅ **Best Practices**

### **1. Use Type Testing for Critical Types**

{% raw %}
```typescript
// ✅ Good: Test critical types
type ApiResponse<T> = {
  success: true;
  data: T;
} | {
  success: false;
  error: string;
};

// Test the type
expectType<ApiResponse<string>>({ success: true, data: 'hello' });
expectType<ApiResponse<string>>({ success: false, error: 'Not found' });

// ❌ Avoid: Not testing complex types
type ComplexType = {
  // Complex type without testing
};
```
{% endraw %}

### **2. Use Runtime Validation for External Data**

{% raw %}
```typescript
// ✅ Good: Validate external data
const validateApiResponse = (data: unknown): ApiResponse<User> => {
  return ApiResponseSchema.parse(data);
};

// ❌ Avoid: Trusting external data
const processApiResponse = (data: any): User => {
  return data.data; // Unsafe!
};
```
{% endraw %}

### **3. Use Type Guards for Runtime Safety**

{% raw %}
```typescript
// ✅ Good: Use type guards
const isUser = (value: unknown): value is User => {
  return typeof value === 'object' && value !== null && 'id' in value;
};

if (isUser(data)) {
  // Safe to use data as User
  console.log(data.name);
}

// ❌ Avoid: Type assertions without validation
const user = data as User; // Unsafe!
```
{% endraw %}

### **4. Test Type Transformations**

{% raw %}
```typescript
// ✅ Good: Test type transformations
type Original = { a: number; b: string; c: boolean };
type Transformed = Pick<Original, 'a' | 'b'>;

expectType<Transformed>({ a: 1, b: 'hello' });

// ❌ Avoid: Not testing type transformations
type UntestedTransformation = {
  // Complex transformation without testing
};
```
{% endraw %}

---

## ❓ **Common Interview Questions**

### **1. What's the difference between compile-time and runtime type checking?**

**Answer:**
- **Compile-time**: TypeScript checks types during compilation
- **Runtime**: JavaScript has no type checking, need validation libraries
- **Compile-time**: Catches errors before deployment
- **Runtime**: Validates data from external sources

### **2. How do you test TypeScript types?**

**Answer:**
- Use `tsd` or `dtslint` for type definition testing
- Use `expectType` and `expectError` for type testing
- Test utility types and conditional types
- Validate type transformations

### **3. What are type guards and when do you use them?**

**Answer:**
Type guards are functions that narrow types at runtime:

{% raw %}
```typescript
const isString = (value: unknown): value is string => {
  return typeof value === 'string';
};
```
{% endraw %}

Use them for runtime type checking and validation.

### **4. How do you validate external data in TypeScript?**

**Answer:**
- Use schema validation libraries like Zod or io-ts
- Create type guards for runtime validation
- Use type assertions with validation
- Implement proper error handling

### **5. What's the difference between type assertions and type guards?**

**Answer:**
- **Type assertions**: Tell TypeScript the type without runtime checking
- **Type guards**: Check types at runtime and narrow the type
- **Type assertions**: `value as Type` (unsafe)
- **Type guards**: `value is Type` (safe)

---

## 🧭 Navigation

<div class="navigation">
  <a href="01-Unit-Testing-TypeScript.md" class="nav-button">← Previous: Unit Testing with TypeScript</a>
  <a href="03-Code-Quality-Linting.md" class="nav-button">Next: Code Quality & Linting →</a>
</div>

*Last updated: December 2025*
