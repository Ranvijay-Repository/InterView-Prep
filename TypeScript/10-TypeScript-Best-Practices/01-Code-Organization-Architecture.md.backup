# üèóÔ∏è **Code Organization & Architecture**

> **Complete guide to TypeScript code organization, architecture patterns, and project structure best practices**

<link rel="stylesheet" href="../../common-styles.css">

---

## üìö **Table of Contents**

- [Code Organization Overview](#code-organization-overview)
- [Project Structure](#project-structure)
- [Architecture Patterns](#architecture-patterns)
- [Module Organization](#module-organization)
- [Naming Conventions](#naming-conventions)
- [Best Practices](#best-practices)
- [Common Interview Questions](#common-interview-questions)

---

## üéØ **Code Organization Overview**

Proper code organization is essential for maintainable, scalable, and collaborative TypeScript projects.

### **Organization Principles**

{% raw %}
```typescript
// Code organization principles
const organizationPrinciples = {
  separationOfConcerns: "Separate different concerns into different modules",
  singleResponsibility: "Each module should have a single responsibility",
  dependencyInversion: "Depend on abstractions, not concretions",
  openClosed: "Open for extension, closed for modification",
  interfaceSegregation: "Use specific interfaces instead of general ones",
  dependencyInjection: "Inject dependencies rather than creating them"
};

// Organization benefits
const organizationBenefits = {
  maintainability: "Easier to maintain and update code",
  scalability: "Easier to scale and extend functionality",
  testability: "Easier to test individual components",
  reusability: "Components can be reused across projects",
  collaboration: "Easier for teams to work together",
  debugging: "Easier to debug and troubleshoot issues"
};

// Organization challenges
const organizationChallenges = {
  complexity: "Managing complexity in large projects",
  dependencies: "Managing dependencies between modules",
  consistency: "Maintaining consistency across the codebase",
  documentation: "Keeping documentation up to date",
  refactoring: "Refactoring without breaking existing code"
};
```
{% endraw %}

### **Code Organization Goals**

{% raw %}
```typescript
// Code organization goals
const organizationGoals = {
  clarity: "Code should be clear and easy to understand",
  modularity: "Code should be modular and loosely coupled",
  consistency: "Code should follow consistent patterns",
  documentation: "Code should be well-documented",
  testing: "Code should be easily testable",
  performance: "Code should be performant and efficient"
};

// Organization metrics
const organizationMetrics = {
  cyclomaticComplexity: "Measure of code complexity",
  coupling: "Degree of coupling between modules",
  cohesion: "Degree of cohesion within modules",
  testCoverage: "Percentage of code covered by tests",
  documentationCoverage: "Percentage of code documented",
  codeDuplication: "Amount of duplicated code"
};
```
{% endraw %}

---

## üìÅ **Project Structure**

### **Basic Project Structure**

{% raw %}
```typescript
// Basic TypeScript project structure
const basicProjectStructure = {
  src: "Source code directory",
  dist: "Compiled output directory",
  tests: "Test files directory",
  docs: "Documentation directory",
  config: "Configuration files directory",
  scripts: "Build and utility scripts"
};

// Example project structure
const exampleProjectStructure = {
  "src/": {
    "components/": "React components",
    "services/": "Business logic services",
    "utils/": "Utility functions",
    "types/": "Type definitions",
    "hooks/": "Custom React hooks",
    "constants/": "Application constants",
    "assets/": "Static assets"
  },
  "tests/": {
    "unit/": "Unit tests",
    "integration/": "Integration tests",
    "e2e/": "End-to-end tests",
    "fixtures/": "Test fixtures"
  },
  "docs/": {
    "api/": "API documentation",
    "guides/": "User guides",
    "examples/": "Code examples"
  }
};
```
{% endraw %}

### **Advanced Project Structure**

{% raw %}
```typescript
// Advanced project structure for large applications
const advancedProjectStructure = {
  "src/": {
    "app/": "Application-specific code",
    "shared/": "Shared code across features",
    "features/": "Feature-based organization",
    "core/": "Core application logic",
    "infrastructure/": "Infrastructure code"
  },
  "features/": {
    "user-management/": "User management feature",
    "product-catalog/": "Product catalog feature",
    "order-processing/": "Order processing feature",
    "reporting/": "Reporting feature"
  },
  "shared/": {
    "components/": "Shared UI components",
    "services/": "Shared services",
    "utils/": "Shared utilities",
    "types/": "Shared type definitions"
  }
};

// Feature-based organization
const featureBasedOrganization = {
  "features/user-management/": {
    "components/": "User management components",
    "services/": "User management services",
    "types/": "User management types",
    "hooks/": "User management hooks",
    "utils/": "User management utilities",
    "tests/": "User management tests"
  }
};
```
{% endraw %}

### **Monorepo Structure**

{% raw %}
```typescript
// Monorepo structure
const monorepoStructure = {
  "packages/": {
    "core/": "Core package",
    "ui/": "UI component library",
    "utils/": "Utility package",
    "types/": "Type definitions package",
    "config/": "Configuration package"
  },
  "apps/": {
    "web/": "Web application",
    "mobile/": "Mobile application",
    "desktop/": "Desktop application",
    "admin/": "Admin application"
  },
  "tools/": {
    "build/": "Build tools",
    "scripts/": "Utility scripts",
    "config/": "Shared configuration"
  }
};

// Package structure
const packageStructure = {
  "src/": "Source code",
  "dist/": "Compiled output",
  "tests/": "Test files",
  "docs/": "Documentation",
  "package.json": "Package configuration",
  "tsconfig.json": "TypeScript configuration",
  "README.md": "Package documentation"
};
```
{% endraw %}

---

## üèõÔ∏è **Architecture Patterns**

### **Layered Architecture**

{% raw %}
```typescript
// Layered architecture pattern
const layeredArchitecture = {
  presentation: "UI layer (components, views)",
  business: "Business logic layer (services, use cases)",
  data: "Data access layer (repositories, APIs)",
  infrastructure: "Infrastructure layer (external services)"
};

// Presentation layer
interface UserView {
  displayUser(user: User): void;
  showError(message: string): void;
}

class UserComponent implements UserView {
  displayUser(user: User): void {
    console.log(`User: ${user.name}`);
  }
  
  showError(message: string): void {
    console.error(message);
  }
}

// Business layer
interface UserService {
  getUser(id: string): Promise<User>;
  createUser(userData: CreateUserRequest): Promise<User>;
}

class UserServiceImpl implements UserService {
  constructor(private userRepository: UserRepository) {}
  
  async getUser(id: string): Promise<User> {
    return this.userRepository.findById(id);
  }
  
  async createUser(userData: CreateUserRequest): Promise<User> {
    // Business logic
    const user = new User(userData);
    return this.userRepository.save(user);
  }
}

// Data layer
interface UserRepository {
  findById(id: string): Promise<User>;
  save(user: User): Promise<User>;
}

class UserRepositoryImpl implements UserRepository {
  async findById(id: string): Promise<User> {
    // Database access
    return new User({ id, name: 'John Doe' });
  }
  
  async save(user: User): Promise<User> {
    // Database save
    return user;
  }
}
```
{% endraw %}

### **Clean Architecture**

{% raw %}
```typescript
// Clean architecture pattern
const cleanArchitecture = {
  entities: "Business entities",
  useCases: "Application use cases",
  interfaces: "Interface adapters",
  frameworks: "Frameworks and drivers"
};

// Entities
class User {
  constructor(
    public id: string,
    public name: string,
    public email: string
  ) {}
  
  isValid(): boolean {
    return this.name.length > 0 && this.email.includes('@');
  }
}

// Use cases
interface GetUserUseCase {
  execute(id: string): Promise<User>;
}

class GetUserUseCaseImpl implements GetUserUseCase {
  constructor(private userRepository: UserRepository) {}
  
  async execute(id: string): Promise<User> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      throw new Error('User not found');
    }
    return user;
  }
}

// Interface adapters
class UserController {
  constructor(private getUserUseCase: GetUserUseCase) {}
  
  async getUser(req: Request, res: Response): Promise<void> {
    try {
      const user = await this.getUserUseCase.execute(req.params.id);
      res.json(user);
    } catch (error) {
      res.status(404).json({ error: error.message });
    }
  }
}

// Frameworks and drivers
class UserRepositoryImpl implements UserRepository {
  async findById(id: string): Promise<User> {
    // Database implementation
    return new User(id, 'John Doe', 'john@example.com');
  }
}
```
{% endraw %}

### **Hexagonal Architecture**

{% raw %}
```typescript
// Hexagonal architecture pattern
const hexagonalArchitecture = {
  domain: "Core business logic",
  ports: "Interfaces for external communication",
  adapters: "Implementations of ports"
};

// Domain
class Order {
  constructor(
    public id: string,
    public customerId: string,
    public items: OrderItem[],
    public status: OrderStatus
  ) {}
  
  calculateTotal(): number {
    return this.items.reduce((total, item) => total + item.price, 0);
  }
  
  canBeCancelled(): boolean {
    return this.status === OrderStatus.PENDING;
  }
}

// Ports
interface OrderRepository {
  save(order: Order): Promise<void>;
  findById(id: string): Promise<Order | null>;
}

interface PaymentService {
  processPayment(amount: number, customerId: string): Promise<PaymentResult>;
}

interface NotificationService {
  sendOrderConfirmation(order: Order): Promise<void>;
}

// Adapters
class OrderRepositoryImpl implements OrderRepository {
  async save(order: Order): Promise<void> {
    // Database implementation
  }
  
  async findById(id: string): Promise<Order | null> {
    // Database implementation
    return null;
  }
}

class PaymentServiceImpl implements PaymentService {
  async processPayment(amount: number, customerId: string): Promise<PaymentResult> {
    // Payment gateway implementation
    return { success: true, transactionId: 'txn_123' };
  }
}

class NotificationServiceImpl implements NotificationService {
  async sendOrderConfirmation(order: Order): Promise<void> {
    // Email/SMS implementation
  }
}
```
{% endraw %}

---

## üì¶ **Module Organization**

### **Module Design Principles**

{% raw %}
```typescript
// Module design principles
const moduleDesignPrinciples = {
  singleResponsibility: "Each module should have one reason to change",
  openClosed: "Open for extension, closed for modification",
  dependencyInversion: "Depend on abstractions, not concretions",
  interfaceSegregation: "Use specific interfaces",
  cohesion: "High cohesion within modules",
  coupling: "Low coupling between modules"
};

// High cohesion example
// ‚úÖ Good: High cohesion
class UserService {
  createUser(userData: CreateUserRequest): Promise<User> {
    // User creation logic
  }
  
  updateUser(id: string, userData: UpdateUserRequest): Promise<User> {
    // User update logic
  }
  
  deleteUser(id: string): Promise<void> {
    // User deletion logic
  }
  
  getUser(id: string): Promise<User> {
    // User retrieval logic
  }
}

// ‚ùå Avoid: Low cohesion
class UserService {
  createUser(userData: CreateUserRequest): Promise<User> {
    // User creation logic
  }
  
  sendEmail(to: string, subject: string, body: string): Promise<void> {
    // Email logic (not related to users)
  }
  
  processPayment(amount: number): Promise<PaymentResult> {
    // Payment logic (not related to users)
  }
}
```
{% endraw %}

### **Module Dependencies**

{% raw %}
```typescript
// Module dependency management
const moduleDependencies = {
  dependencyInjection: "Inject dependencies rather than creating them",
  interfaces: "Use interfaces to define contracts",
  factories: "Use factories to create objects",
  singletons: "Use singletons for shared resources",
  observers: "Use observer pattern for loose coupling"
};

// Dependency injection
interface UserRepository {
  findById(id: string): Promise<User>;
  save(user: User): Promise<User>;
}

class UserService {
  constructor(private userRepository: UserRepository) {}
  
  async getUser(id: string): Promise<User> {
    return this.userRepository.findById(id);
  }
  
  async createUser(userData: CreateUserRequest): Promise<User> {
    const user = new User(userData);
    return this.userRepository.save(user);
  }
}

// Factory pattern
class UserServiceFactory {
  static create(): UserService {
    const userRepository = new UserRepositoryImpl();
    return new UserService(userRepository);
  }
}

// Observer pattern
interface UserObserver {
  onUserCreated(user: User): void;
  onUserUpdated(user: User): void;
}

class UserService {
  private observers: UserObserver[] = [];
  
  addObserver(observer: UserObserver): void {
    this.observers.push(observer);
  }
  
  removeObserver(observer: UserObserver): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }
  
  private notifyUserCreated(user: User): void {
    this.observers.forEach(observer => observer.onUserCreated(user));
  }
  
  private notifyUserUpdated(user: User): void {
    this.observers.forEach(observer => observer.onUserUpdated(user));
  }
}
```
{% endraw %}

### **Module Communication**

{% raw %}
```typescript
// Module communication patterns
const moduleCommunication = {
  events: "Use events for loose coupling",
  messages: "Use message passing",
  sharedState: "Use shared state management",
  callbacks: "Use callbacks for async communication",
  promises: "Use promises for async operations"
};

// Event-based communication
class EventBus {
  private listeners = new Map<string, Function[]>();
  
  on(event: string, listener: Function): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event)!.push(listener);
  }
  
  off(event: string, listener: Function): void {
    const listeners = this.listeners.get(event) || [];
    const index = listeners.indexOf(listener);
    if (index > -1) {
      listeners.splice(index, 1);
    }
  }
  
  emit(event: string, data: any): void {
    const listeners = this.listeners.get(event) || [];
    listeners.forEach(listener => listener(data));
  }
}

// Message passing
interface Message {
  type: string;
  payload: any;
}

class MessageBus {
  private handlers = new Map<string, Function[]>();
  
  subscribe(messageType: string, handler: Function): void {
    if (!this.handlers.has(messageType)) {
      this.handlers.set(messageType, []);
    }
    this.handlers.get(messageType)!.push(handler);
  }
  
  publish(message: Message): void {
    const handlers = this.handlers.get(message.type) || [];
    handlers.forEach(handler => handler(message.payload));
  }
}

// Shared state management
class StateManager {
  private state: any = {};
  private listeners: Function[] = [];
  
  getState(): any {
    return this.state;
  }
  
  setState(newState: any): void {
    this.state = { ...this.state, ...newState };
    this.listeners.forEach(listener => listener(this.state));
  }
  
  subscribe(listener: Function): void {
    this.listeners.push(listener);
  }
  
  unsubscribe(listener: Function): void {
    const index = this.listeners.indexOf(listener);
    if (index > -1) {
      this.listeners.splice(index, 1);
    }
  }
}
```
{% endraw %}

---

## üìù **Naming Conventions**

### **File and Directory Naming**

{% raw %}
```typescript
// File and directory naming conventions
const namingConventions = {
  files: "Use kebab-case for files",
  directories: "Use kebab-case for directories",
  components: "Use PascalCase for component files",
  utilities: "Use camelCase for utility files",
  constants: "Use UPPER_SNAKE_CASE for constants",
  types: "Use PascalCase for type files"
};

// File naming examples
const fileNamingExamples = {
  components: "UserProfile.tsx",
  services: "userService.ts",
  utilities: "dateUtils.ts",
  constants: "API_CONSTANTS.ts",
  types: "UserTypes.ts",
  hooks: "useUserData.ts",
  tests: "userService.test.ts"
};

// Directory naming examples
const directoryNamingExamples = {
  features: "user-management/",
  components: "ui-components/",
  services: "business-services/",
  utilities: "shared-utils/",
  types: "type-definitions/",
  tests: "unit-tests/"
};
```
{% endraw %}

### **Variable and Function Naming**

{% raw %}
```typescript
// Variable and function naming conventions
const variableNaming = {
  variables: "Use camelCase for variables",
  functions: "Use camelCase for functions",
  constants: "Use UPPER_SNAKE_CASE for constants",
  private: "Use underscore prefix for private members",
  interfaces: "Use PascalCase for interfaces",
  types: "Use PascalCase for types",
  enums: "Use PascalCase for enums"
};

// Variable naming examples
const variableExamples = {
  variables: "userName, isLoggedIn, userCount",
  functions: "getUserData, createUser, validateEmail",
  constants: "API_BASE_URL, MAX_RETRY_ATTEMPTS",
  private: "_privateMethod, _internalState",
  interfaces: "User, UserService, UserRepository",
  types: "UserStatus, CreateUserRequest",
  enums: "OrderStatus, PaymentMethod"
};

// Function naming examples
const functionExamples = {
  getters: "getUserById, getUserName, getUserEmail",
  setters: "setUserName, setUserEmail, setUserStatus",
  validators: "isValidEmail, isUserActive, canUserAccess",
  creators: "createUser, createOrder, createPayment",
  updaters: "updateUser, updateOrder, updatePayment",
  deleters: "deleteUser, deleteOrder, deletePayment"
};
```
{% endraw %}

### **Class and Interface Naming**

{% raw %}
```typescript
// Class and interface naming conventions
const classNaming = {
  classes: "Use PascalCase for classes",
  interfaces: "Use PascalCase for interfaces",
  abstract: "Use Abstract prefix for abstract classes",
  base: "Use Base suffix for base classes",
  implementation: "Use Impl suffix for implementations",
  factory: "Use Factory suffix for factories",
  builder: "Use Builder suffix for builders"
};

// Class naming examples
const classExamples = {
  classes: "User, Order, Payment, UserService",
  interfaces: "UserRepository, PaymentService, NotificationService",
  abstract: "AbstractUserService, AbstractRepository",
  base: "BaseEntity, BaseService, BaseRepository",
  implementation: "UserServiceImpl, UserRepositoryImpl",
  factory: "UserServiceFactory, PaymentServiceFactory",
  builder: "UserBuilder, OrderBuilder, PaymentBuilder"
};

// Interface naming examples
const interfaceExamples = {
  repositories: "UserRepository, OrderRepository, PaymentRepository",
  services: "UserService, OrderService, PaymentService",
  controllers: "UserController, OrderController, PaymentController",
  models: "User, Order, Payment, Product",
  requests: "CreateUserRequest, UpdateUserRequest, DeleteUserRequest",
  responses: "UserResponse, OrderResponse, PaymentResponse"
};
```
{% endraw %}

---

## ‚úÖ **Best Practices**

### **1. Follow Single Responsibility Principle**

{% raw %}
```typescript
// ‚úÖ Good: Single responsibility
class UserService {
  async getUser(id: string): Promise<User> {
    // Only user-related operations
  }
  
  async createUser(userData: CreateUserRequest): Promise<User> {
    // Only user-related operations
  }
}

// ‚ùå Avoid: Multiple responsibilities
class UserService {
  async getUser(id: string): Promise<User> {
    // User operations
  }
  
  async sendEmail(to: string, subject: string): Promise<void> {
    // Email operations (not user-related)
  }
  
  async processPayment(amount: number): Promise<PaymentResult> {
    // Payment operations (not user-related)
  }
}
```
{% endraw %}

### **2. Use Dependency Injection**

{% raw %}
```typescript
// ‚úÖ Good: Dependency injection
class UserService {
  constructor(private userRepository: UserRepository) {}
  
  async getUser(id: string): Promise<User> {
    return this.userRepository.findById(id);
  }
}

// ‚ùå Avoid: Direct dependency creation
class UserService {
  async getUser(id: string): Promise<User> {
    const userRepository = new UserRepositoryImpl(); // Hard dependency
    return userRepository.findById(id);
  }
}
```
{% endraw %}

### **3. Organize by Feature**

{% raw %}
```typescript
// ‚úÖ Good: Feature-based organization
const featureOrganization = {
  "features/user-management/": {
    "components/": "User components",
    "services/": "User services",
    "types/": "User types",
    "tests/": "User tests"
  }
};

// ‚ùå Avoid: Technical-based organization
const technicalOrganization = {
  "components/": "All components mixed together",
  "services/": "All services mixed together",
  "types/": "All types mixed together"
};
```
{% endraw %}

### **4. Use Consistent Naming**

{% raw %}
```typescript
// ‚úÖ Good: Consistent naming
const consistentNaming = {
  files: "userService.ts, userTypes.ts, userUtils.ts",
  classes: "UserService, UserRepository, UserController",
  interfaces: "User, UserService, UserRepository",
  functions: "getUser, createUser, updateUser, deleteUser"
};

// ‚ùå Avoid: Inconsistent naming
const inconsistentNaming = {
  files: "userService.ts, UserTypes.ts, user_utils.ts",
  classes: "UserService, userRepository, User_Controller",
  interfaces: "User, userService, User_Repository",
  functions: "getUser, CreateUser, update_user, deleteUser"
};
```
{% endraw %}

---

## ‚ùì **Common Interview Questions**

### **1. How do you organize TypeScript code in large projects?**

**Answer:**
- **Feature-based**: Organize by business features
- **Layered Architecture**: Separate presentation, business, and data layers
- **Module Design**: Use single responsibility and dependency injection
- **Consistent Naming**: Follow consistent naming conventions
- **Documentation**: Maintain clear documentation

### **2. What are the benefits of good code organization?**

**Answer:**
- **Maintainability**: Easier to maintain and update
- **Scalability**: Easier to scale and extend
- **Testability**: Easier to test individual components
- **Reusability**: Components can be reused
- **Collaboration**: Easier for teams to work together

### **3. How do you handle dependencies between modules?**

**Answer:**
- **Dependency Injection**: Inject dependencies rather than creating them
- **Interfaces**: Use interfaces to define contracts
- **Factories**: Use factories to create objects
- **Events**: Use events for loose coupling
- **Shared State**: Use shared state management

### **4. What architecture patterns do you use in TypeScript?**

**Answer:**
- **Layered Architecture**: Separate concerns into layers
- **Clean Architecture**: Use cases and entities
- **Hexagonal Architecture**: Ports and adapters
- **MVC**: Model-View-Controller
- **MVVM**: Model-View-ViewModel

### **5. How do you ensure code consistency across a team?**

**Answer:**
- **Naming Conventions**: Establish clear naming conventions
- **Code Style**: Use ESLint and Prettier
- **Documentation**: Maintain clear documentation
- **Code Reviews**: Regular code reviews
- **Training**: Team training on best practices

---

## üß≠ Navigation

<div class="navigation">
  <a href="../09-TypeScript-Performance-Optimization/04-Memory-Management.md" class="nav-button">‚Üê Previous: Memory Management</a>
  <a href="02-Type-Safety-Best-Practices.md" class="nav-button">Next: Type Safety Best Practices ‚Üí</a>
</div>

*Last updated: December 2025*
