# üì¶ **Modules & Imports**

> **Complete guide to TypeScript modules, import/export syntax, module resolution, and advanced module patterns**

<link rel="stylesheet" href="../../common-styles.css">

---

## üìö **Table of Contents**

- [Module System Overview](#module-system-overview)
- [Export Syntax](#export-syntax)
- [Import Syntax](#import-syntax)
- [Module Resolution](#module-resolution)
- [Type-Only Imports](#type-only-imports)
- [Dynamic Imports](#dynamic-imports)
- [Best Practices](#best-practices)
- [Common Interview Questions](#common-interview-questions)

---

## üéØ **Module System Overview**

TypeScript supports both CommonJS and ES6 module systems, providing flexibility for different environments.

### **Module Types**

{% raw %}
```typescript
// ES6 Modules (recommended)
export interface User {
  id: number;
  name: string;
}

export class UserService {
  // Implementation
}

// CommonJS (Node.js style)
module.exports = {
  User: class User { },
  UserService: class UserService { }
};
```
{% endraw %}

### **Module vs Script**

{% raw %}
```typescript
// Script file (no imports/exports)
const message = "Hello World";
console.log(message);

// Module file (has imports/exports)
export const message = "Hello World";
import { message } from "./script";
```
{% endraw %}

---

## üì§ **Export Syntax**

TypeScript provides multiple ways to export values, types, and interfaces.

### **Named Exports**

{% raw %}
```typescript
// Export individual items
export interface User {
  id: number;
  name: string;
  email: string;
}

export class UserService {
  private users: User[] = [];

  addUser(user: User): void {
    this.users.push(user);
  }

  getUser(id: number): User | undefined {
    return this.users.find(user => user.id === id);
  }
}

// Export constants and functions
export const API_URL = "https://api.example.com";
export const MAX_USERS = 100;

export function validateUser(user: User): boolean {
  return user.name.length > 0 && user.email.includes("@");
}

// Export type aliases
export type UserId = number;
export type UserStatus = "active" | "inactive" | "pending";
```
{% endraw %}

### **Default Exports**

{% raw %}
```typescript
// Default export (one per module)
export default class UserRepository {
  private users: User[] = [];

  save(user: User): User {
    this.users.push(user);
    return user;
  }

  findById(id: number): User | undefined {
    return this.users.find(user => user.id === id);
  }
}

// Default export with function
export default function createUser(name: string, email: string): User {
  return {
    id: Date.now(),
    name,
    email
  };
}

// Default export with object
export default {
  API_URL: "https://api.example.com",
  VERSION: "1.0.0",
  getEndpoint: (path: string) => `${API_URL}${path}`
};
```
{% endraw %}

### **Re-exports**

{% raw %}
```typescript
// Re-export from another module
export { User, UserService } from "./user";
export { Product, ProductService } from "./product";

// Re-export with renaming
export { User as UserType } from "./user";
export { Product as ProductType } from "./product";

// Re-export everything
export * from "./user";
export * from "./product";

// Re-export with namespace
export * as UserModule from "./user";
export * as ProductModule from "./product";
```
{% endraw %}

---

## üì• **Import Syntax**

TypeScript provides flexible import syntax for different use cases.

### **Named Imports**

{% raw %}
```typescript
// Import specific items
import { User, UserService } from "./user";
import { API_URL, MAX_USERS } from "./constants";

// Import with renaming
import { User as UserType, UserService as Service } from "./user";

// Import everything into namespace
import * as UserModule from "./user";

// Usage
const user: UserType = { id: 1, name: "John", email: "john@example.com" };
const service = new Service();
const apiUrl = UserModule.API_URL;
```
{% endraw %}

### **Default Imports**

{% raw %}
```typescript
// Import default export
import UserRepository from "./user-repository";
import createUser from "./user-factory";

// Import default with renaming
import UserRepo from "./user-repository";

// Usage
const repository = new UserRepository();
const user = createUser("John", "john@example.com");
```
{% endraw %}

### **Mixed Imports**

{% raw %}
```typescript
// Import both default and named exports
import UserRepository, { User, UserService } from "./user";

// Import default with namespace
import UserRepo, * as UserTypes from "./user";

// Usage
const repository = new UserRepo();
const user: UserTypes.User = { id: 1, name: "John", email: "john@example.com" };
```
{% endraw %}

---

## üîç **Module Resolution**

TypeScript uses different module resolution strategies based on configuration.

### **Module Resolution Strategies**

{% raw %}
```json
// tsconfig.json
{
  "compilerOptions": {
    "moduleResolution": "node", // or "classic"
    "baseUrl": "./src",
    "paths": {
      "@/*": ["*"],
      "@/components/*": ["components/*"],
      "@/utils/*": ["utils/*"]
    }
  }
}
```
{% endraw %}

### **Path Mapping**

{% raw %}
```typescript
// Using path mapping
import { User } from "@/types/user";
import { UserService } from "@/services/user-service";
import { Button } from "@/components/Button";

// Without path mapping
import { User } from "../../types/user";
import { UserService } from "../services/user-service";
import { Button } from "./components/Button";
```
{% endraw %}

### **Module Resolution Examples**

{% raw %}
```typescript
// Relative imports
import { User } from "./user";           // Same directory
import { User } from "../user";          // Parent directory
import { User } from "../../user";       // Grandparent directory

// Absolute imports (with baseUrl)
import { User } from "types/user";       // From baseUrl
import { User } from "src/types/user";   // From project root

// Node modules
import React from "react";
import { useState } from "react";
import * as _ from "lodash";
```
{% endraw %}

---

## üé≠ **Type-Only Imports**

TypeScript provides type-only imports for better performance and clarity.

### **Type-Only Import Syntax**

{% raw %}
```typescript
// Type-only imports
import type { User, UserService } from "./user";
import type { ComponentProps } from "react";

// Mixed imports (value + type)
import { UserService, type User } from "./user";
import React, { type ComponentProps } from "react";

// Type-only default import
import type UserRepository from "./user-repository";

// Usage
const service = new UserService(); // Runtime import
const user: User = { id: 1, name: "John", email: "john@example.com" }; // Type-only
```
{% endraw %}

### **When to Use Type-Only Imports**

{% raw %}
```typescript
// ‚úÖ Good: Use type-only for interfaces and types
import type { User, UserStatus } from "./user";
import type { ComponentProps } from "react";

// ‚úÖ Good: Use type-only for default exports that are types
import type UserRepository from "./user-repository";

// ‚ùå Avoid: Type-only for runtime values
import type { UserService } from "./user"; // UserService is a class, not a type
```
{% endraw %}

---

## ‚ö° **Dynamic Imports**

Dynamic imports allow you to load modules at runtime, enabling code splitting and lazy loading.

### **Basic Dynamic Imports**

{% raw %}
```typescript
// Dynamic import with async/await
const loadUserModule = async () => {
  const { User, UserService } = await import("./user");
  return { User, UserService };
};

// Dynamic import with Promise
const loadUserModule = () => {
  return import("./user").then(module => {
    return { User: module.User, UserService: module.UserService };
  });
};

// Usage
const initializeApp = async () => {
  const { UserService } = await loadUserModule();
  const userService = new UserService();
  // Use userService
};
```
{% endraw %}

### **Dynamic Imports with Type Safety**

{% raw %}
```typescript
// Dynamic import with type assertion
const loadUserService = async (): Promise<typeof import("./user")> => {
  return import("./user");
};

// Dynamic import with generic type
const loadModule = async <T>(modulePath: string): Promise<T> => {
  return import(modulePath) as Promise<T>;
};

// Usage
const userModule = await loadUserService();
const userService = new userModule.UserService();

// Or with generic
const userModule = await loadModule<typeof import("./user")>("./user");
```
{% endraw %}

### **Dynamic Imports in React**

{% raw %}
```typescript
// Lazy loading React components
import { lazy, Suspense } from "react";

const UserProfile = lazy(() => import("./UserProfile"));
const UserSettings = lazy(() => import("./UserSettings"));

const App = () => {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <UserProfile />
      <UserSettings />
    </Suspense>
  );
};
```
{% endraw %}

---

## ‚úÖ **Best Practices**

### **1. Use Named Exports for Multiple Items**

{% raw %}
```typescript
// ‚úÖ Good: Named exports for multiple related items
export interface User {
  id: number;
  name: string;
}

export class UserService {
  // Implementation
}

export const API_URL = "https://api.example.com";

// ‚ùå Avoid: Default export for multiple items
export default {
  User: interface User { },
  UserService: class UserService { },
  API_URL: "https://api.example.com"
};
```
{% endraw %}

### **2. Use Default Exports for Single Main Item**

{% raw %}
```typescript
// ‚úÖ Good: Default export for main class/function
export default class UserRepository {
  // Implementation
}

// ‚ùå Avoid: Default export for multiple items
export default {
  UserRepository: class UserRepository { },
  UserService: class UserService { }
};
```
{% endraw %}

### **3. Use Type-Only Imports for Types**

{% raw %}
```typescript
// ‚úÖ Good: Type-only imports for interfaces and types
import type { User, UserStatus } from "./user";
import { UserService } from "./user"; // Runtime import

// ‚ùå Avoid: Regular imports for types only
import { User, UserStatus, UserService } from "./user";
```
{% endraw %}

### **4. Use Path Mapping for Clean Imports**

{% raw %}
```typescript
// ‚úÖ Good: Path mapping for clean imports
import { User } from "@/types/user";
import { UserService } from "@/services/user-service";

// ‚ùå Avoid: Relative imports for deep nesting
import { User } from "../../../types/user";
import { UserService } from "../../services/user-service";
```
{% endraw %}

---

## ‚ùì **Common Interview Questions**

### **1. What's the difference between named and default exports?**

**Answer:**
- **Named exports**: Export multiple items with specific names, imported with `{ }`
- **Default exports**: Export one main item, imported without `{ }`

{% raw %}
```typescript
// Named export
export const name = "John";
import { name } from "./module";

// Default export
export default class User { }
import User from "./module";
```
{% endraw %}

### **2. How do you handle circular dependencies in TypeScript?**

**Answer:**
- Use dynamic imports
- Restructure code to avoid circular references
- Use dependency injection
- Split shared code into separate modules

### **3. What are type-only imports and when should you use them?**

**Answer:**
Type-only imports are removed at runtime and only used for type checking:

{% raw %}
```typescript
import type { User } from "./user"; // Removed at compile time
import { UserService } from "./user"; // Included at runtime
```
{% endraw %}

### **4. How do you configure module resolution in TypeScript?**

**Answer:**
Configure in `tsconfig.json`:

{% raw %}
```json
{
  "compilerOptions": {
    "moduleResolution": "node",
    "baseUrl": "./src",
    "paths": {
      "@/*": ["*"]
    }
  }
}
```
{% endraw %}

### **5. What's the difference between ES6 modules and CommonJS?**

**Answer:**
- **ES6 modules**: Static imports/exports, tree-shaking, better optimization
- **CommonJS**: Dynamic imports/exports, runtime resolution, Node.js standard

---

## üß≠ Navigation

<div class="navigation">
  <a href="01-ES6-Features-TypeScript.md" class="nav-button">‚Üê Previous: ES6+ Features & TypeScript</a>
  <a href="03-Async-Await-Promises.md" class="nav-button">Next: Async/Await & Promises ‚Üí</a>
</div>

*Last updated: December 2025*
