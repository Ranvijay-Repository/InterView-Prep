# üîß **Generics & Type Parameters**

> **Complete guide to TypeScript generics, type parameters, constraints, and advanced generic patterns**

<link rel="stylesheet" href="../../common-styles.css">

---

## üìö **Table of Contents**

- [Introduction to Generics](#introduction-to-generics)
- [Generic Functions](#generic-functions)
- [Generic Classes](#generic-classes)
- [Generic Interfaces](#generic-interfaces)
- [Generic Constraints](#generic-constraints)
- [Advanced Generic Patterns](#advanced-generic-patterns)
- [Best Practices](#best-practices)
- [Common Interview Questions](#common-interview-questions)

---

## üéØ **Introduction to Generics**

Generics allow you to create reusable components that work with multiple types while maintaining type safety.

### **Why Use Generics?**

{% raw %}
```typescript
// Without generics - not type-safe
function getFirstItem(items: any[]): any {
  return items[0];
}

const firstNumber = getFirstItem([1, 2, 3]); // Returns any
const firstString = getFirstItem(["a", "b", "c"]); // Returns any

// With generics - type-safe
function getFirstItem<T>(items: T[]): T {
  return items[0];
}

const firstNumber = getFirstItem([1, 2, 3]); // Returns number
const firstString = getFirstItem(["a", "b", "c"]); // Returns string
```
{% endraw %}

### **Basic Generic Syntax**

{% raw %}
```typescript
// Generic function
function identity<T>(arg: T): T {
  return arg;
}

// Usage with explicit type
const result1 = identity<string>("hello"); // result1 is string
const result2 = identity<number>(42);      // result2 is number

// Usage with type inference
const result3 = identity("hello"); // TypeScript infers T as string
const result4 = identity(42);      // TypeScript infers T as number
```
{% endraw %}

---

## üîß **Generic Functions**

Generic functions can work with different types while maintaining type safety.

### **Basic Generic Functions**

{% raw %}
```typescript
// Generic function with single type parameter
function logAndReturn<T>(value: T): T {
  console.log(value);
  return value;
}

// Generic function with multiple type parameters
function pair<T, U>(first: T, second: U): [T, U] {
  return [first, second];
}

// Usage
const stringValue = logAndReturn("hello"); // T inferred as string
const numberValue = logAndReturn(42);      // T inferred as number
const pairResult = pair("hello", 42);      // [string, number]
```
{% endraw %}

### **Generic Array Functions**

{% raw %}
```typescript
// Generic function for array operations
function getLastItem<T>(array: T[]): T | undefined {
  return array[array.length - 1];
}

function filterArray<T>(array: T[], predicate: (item: T) => boolean): T[] {
  return array.filter(predicate);
}

// Usage
const numbers = [1, 2, 3, 4, 5];
const lastNumber = getLastItem(numbers); // number | undefined
const evenNumbers = filterArray(numbers, n => n % 2 === 0); // number[]
```
{% endraw %}

### **Generic Function with Constraints**

{% raw %}
```typescript
// Generic function with length property constraint
function getLength<T extends { length: number }>(item: T): number {
  return item.length;
}

// Usage
getLength("hello");        // 5
getLength([1, 2, 3]);      // 3
getLength({ length: 10 }); // 10
```
{% endraw %}

---

## üèóÔ∏è **Generic Classes**

Generic classes allow you to create classes that work with different types.

### **Basic Generic Class**

{% raw %}
```typescript
// Generic container class
class Container<T> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  get(index: number): T | undefined {
    return this.items[index];
  }

  getAll(): T[] {
    return [...this.items];
  }

  size(): number {
    return this.items.length;
  }
}

// Usage
const stringContainer = new Container<string>();
stringContainer.add("hello");
stringContainer.add("world");

const numberContainer = new Container<number>();
numberContainer.add(1);
numberContainer.add(2);
```
{% endraw %}

### **Generic Class with Multiple Type Parameters**

{% raw %}
```typescript
// Generic key-value storage
class KeyValueStore<K, V> {
  private store = new Map<K, V>();

  set(key: K, value: V): void {
    this.store.set(key, value);
  }

  get(key: K): V | undefined {
    return this.store.get(key);
  }

  has(key: K): boolean {
    return this.store.has(key);
  }

  delete(key: K): boolean {
    return this.store.delete(key);
  }
}

// Usage
const userStore = new KeyValueStore<string, { name: string; age: number }>();
userStore.set("user1", { name: "John", age: 30 });
userStore.set("user2", { name: "Jane", age: 25 });
```
{% endraw %}

### **Generic Class with Constraints**

{% raw %}
```typescript
// Generic class with comparable constraint
interface Comparable<T> {
  compareTo(other: T): number;
}

class SortedList<T extends Comparable<T>> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
    this.items.sort((a, b) => a.compareTo(b));
  }

  get(index: number): T | undefined {
    return this.items[index];
  }

  getAll(): T[] {
    return [...this.items];
  }
}

// Usage with a comparable class
class Person implements Comparable<Person> {
  constructor(public name: string, public age: number) {}

  compareTo(other: Person): number {
    return this.age - other.age;
  }
}

const sortedPeople = new SortedList<Person>();
sortedPeople.add(new Person("Alice", 30));
sortedPeople.add(new Person("Bob", 25));
```
{% endraw %}

---

## üìã **Generic Interfaces**

Generic interfaces define contracts that can work with different types.

### **Basic Generic Interface**

{% raw %}
```typescript
// Generic repository interface
interface Repository<T> {
  findById(id: string): T | undefined;
  findAll(): T[];
  save(entity: T): T;
  delete(id: string): boolean;
}

// Implementation
class UserRepository implements Repository<User> {
  private users: User[] = [];

  findById(id: string): User | undefined {
    return this.users.find(user => user.id === id);
  }

  findAll(): User[] {
    return [...this.users];
  }

  save(user: User): User {
    const existingIndex = this.users.findIndex(u => u.id === user.id);
    if (existingIndex >= 0) {
      this.users[existingIndex] = user;
    } else {
      this.users.push(user);
    }
    return user;
  }

  delete(id: string): boolean {
    const index = this.users.findIndex(user => user.id === id);
    if (index >= 0) {
      this.users.splice(index, 1);
      return true;
    }
    return false;
  }
}
```
{% endraw %}

### **Generic Interface with Multiple Type Parameters**

{% raw %}
```typescript
// Generic API response interface
interface ApiResponse<T, E = string> {
  data: T;
  error: E | null;
  status: "success" | "error";
  timestamp: string;
}

// Usage
type UserApiResponse = ApiResponse<User>;
type UserListApiResponse = ApiResponse<User[]>;
type CustomErrorResponse = ApiResponse<User, { code: number; message: string }>;
```
{% endraw %}

### **Generic Interface with Constraints**

{% raw %}
```typescript
// Generic interface with serializable constraint
interface Serializable {
  toJSON(): string;
}

interface Cache<T extends Serializable> {
  get(key: string): T | undefined;
  set(key: string, value: T): void;
  clear(): void;
}

// Implementation
class MemoryCache<T extends Serializable> implements Cache<T> {
  private cache = new Map<string, T>();

  get(key: string): T | undefined {
    return this.cache.get(key);
  }

  set(key: string, value: T): void {
    this.cache.set(key, value);
  }

  clear(): void {
    this.cache.clear();
  }
}
```
{% endraw %}

---

## üîí **Generic Constraints**

Constraints limit the types that can be used with generics, providing more specific type information.

### **Basic Constraints**

{% raw %}
```typescript
// Constraint to ensure type has length property
function getLength<T extends { length: number }>(item: T): number {
  return item.length;
}

// Usage
getLength("hello");        // 5
getLength([1, 2, 3]);      // 3
getLength({ length: 10 }); // 10
// getLength(42);          // ‚ùå Error: number doesn't have length property
```
{% endraw %}

### **Keyof Constraint**

{% raw %}
```typescript
// Constraint using keyof
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// Usage
const person = { name: "John", age: 30, city: "New York" };
const name = getProperty(person, "name"); // string
const age = getProperty(person, "age");   // number
// const invalid = getProperty(person, "invalid"); // ‚ùå Error
```
{% endraw %}

### **Multiple Constraints**

{% raw %}
```typescript
// Multiple constraints
interface HasId {
  id: string;
}

interface HasName {
  name: string;
}

function processEntity<T extends HasId & HasName>(entity: T): string {
  return `${entity.name} (ID: ${entity.id})`;
}

// Usage
const user = { id: "1", name: "John", email: "john@example.com" };
const result = processEntity(user); // "John (ID: 1)"
```
{% endraw %}

---

## üöÄ **Advanced Generic Patterns**

### **Conditional Types with Generics**

{% raw %}
```typescript
// Conditional type based on generic parameter
type ApiResponse<T> = T extends string 
  ? { message: T } 
  : { data: T };

function createResponse<T>(value: T): ApiResponse<T> {
  if (typeof value === "string") {
    return { message: value } as ApiResponse<T>;
  }
  return { data: value } as ApiResponse<T>;
}

// Usage
const stringResponse = createResponse("Hello"); // { message: string }
const numberResponse = createResponse(42);      // { data: number }
```
{% endraw %}

### **Mapped Types with Generics**

{% raw %}
```typescript
// Generic mapped type
type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Required<T> = {
  [P in keyof T]-?: T[P];
};

// Usage
interface User {
  id: string;
  name: string;
  email: string;
}

type PartialUser = Partial<User>; // All properties optional
type RequiredUser = Required<User>; // All properties required
```
{% endraw %}

### **Generic Utility Types**

{% raw %}
```typescript
// Generic utility type for API responses
type ApiResult<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

// Generic function using utility type
async function fetchData<T>(url: string): Promise<ApiResult<T>> {
  try {
    const response = await fetch(url);
    const data = await response.json();
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}

// Usage
const result = await fetchData<User[]>("/api/users");
if (result.success) {
  console.log(result.data); // T[]
} else {
  console.error(result.error); // Error
}
```
{% endraw %}

---

## ‚úÖ **Best Practices**

### **1. Use Descriptive Generic Names**

{% raw %}
```typescript
// ‚úÖ Good: Descriptive generic names
function processUserData<TUser extends User, TResponse extends ApiResponse<TUser>>(
  user: TUser
): TResponse {
  // Implementation
}

// ‚ùå Avoid: Generic names like T, U, V
function processUserData<T, U, V>(user: T): U {
  // Implementation
}
```
{% endraw %}

### **2. Use Constraints to Provide Better Type Safety**

{% raw %}
```typescript
// ‚úÖ Good: Constraint provides type safety
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// ‚ùå Avoid: No constraints, less type safety
function getProperty(obj: any, key: string): any {
  return obj[key];
}
```
{% endraw %}

### **3. Prefer Type Inference When Possible**

{% raw %}
```typescript
// ‚úÖ Good: Let TypeScript infer the type
const result = getFirstItem([1, 2, 3]); // T inferred as number

// ‚ùå Avoid: Unnecessary explicit type
const result = getFirstItem<number>([1, 2, 3]);
```
{% endraw %}

### **4. Use Generic Constraints for Better APIs**

{% raw %}
```typescript
// ‚úÖ Good: Constraint ensures required properties
function createEntity<T extends { id: string; name: string }>(
  data: T
): T {
  return { ...data, createdAt: new Date() };
}
```
{% endraw %}

---

## ‚ùì **Common Interview Questions**

### **1. What are generics and why are they useful?**

**Answer:**
Generics allow you to create reusable components that work with multiple types while maintaining type safety. They provide:
- Type safety at compile time
- Code reusability
- Better IntelliSense support
- Elimination of type casting

### **2. How do you create a generic function?**

**Answer:**
Use angle brackets to define type parameters:

{% raw %}
```typescript
function identity<T>(arg: T): T {
  return arg;
}

// Usage
const result = identity<string>("hello");
const inferred = identity("hello"); // Type inferred
```
{% endraw %}

### **3. What are generic constraints and how do you use them?**

**Answer:**
Constraints limit the types that can be used with generics:

{% raw %}
```typescript
function getLength<T extends { length: number }>(item: T): number {
  return item.length;
}
```
{% endraw %}

### **4. How do you create a generic class?**

**Answer:**
Define type parameters after the class name:

{% raw %}
```typescript
class Container<T> {
  private items: T[] = [];
  
  add(item: T): void {
    this.items.push(item);
  }
  
  get(index: number): T | undefined {
    return this.items[index];
  }
}
```
{% endraw %}

### **5. What's the difference between generic functions and generic classes?**

**Answer:**
- **Generic functions**: Work with different types for a single operation
- **Generic classes**: Maintain type consistency across multiple methods and properties

{% raw %}
```typescript
// Generic function
function process<T>(item: T): T { return item; }

// Generic class
class Processor<T> {
  process(item: T): T { return item; }
  store(item: T): void { /* store */ }
}
```
{% endraw %}

---

## üß≠ Navigation

<div class="navigation">
  <a href="01-Union-Intersection-Types.md" class="nav-button">‚Üê Previous: Union & Intersection Types</a>
  <a href="03-Conditional-Types.md" class="nav-button">Next: Conditional Types ‚Üí</a>
</div>

*Last updated: December 2025*
