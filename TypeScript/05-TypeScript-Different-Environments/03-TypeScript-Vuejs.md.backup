# üíö **TypeScript with Vue.js**

> **Complete guide to using TypeScript with Vue.js, including component typing, composition API, and advanced patterns**

<link rel="stylesheet" href="../../common-styles.css">

---

## üìö **Table of Contents**

- [Vue.js TypeScript Setup](#vuejs-typescript-setup)
- [Component Typing](#component-typing)
- [Composition API](#composition-api)
- [Props and Emits](#props-and-emits)
- [Reactive Data](#reactive-data)
- [Advanced Patterns](#advanced-patterns)
- [Best Practices](#best-practices)
- [Common Interview Questions](#common-interview-questions)

---

## üéØ **Vue.js TypeScript Setup**

Setting up TypeScript with Vue.js requires proper configuration and understanding of Vue's type system.

### **Basic Setup**

{% raw %}
```bash
# Create Vue app with TypeScript
npm create vue@latest my-app
# Select TypeScript when prompted

# Or add TypeScript to existing project
npm install --save-dev typescript @vue/tsconfig
npm install --save-dev @types/node
```
{% endraw %}

### **TypeScript Configuration**

{% raw %}
```json
// tsconfig.json
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "include": [
    "env.d.ts",
    "src/**/*",
    "src/**/*.vue"
  ],
  "exclude": [
    "src/**/__tests__/*"
  ],
  "compilerOptions": {
    "composite": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```
{% endraw %}

### **Vite Configuration**

{% raw %}
```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  }
})
```
{% endraw %}

---

## üß© **Component Typing**

### **Options API with TypeScript**

{% raw %}
```vue
<!-- UserCard.vue -->
<template>
  <div class="user-card">
    <h3>{{ user.name }}</h3>
    <p>{{ user.email }}</p>
    <button @click="handleEdit">Edit</button>
  </div>
</template>

<script lang="ts">
import { defineComponent, PropType } from 'vue'

interface User {
  id: number
  name: string
  email: string
}

export default defineComponent({
  name: 'UserCard',
  props: {
    user: {
      type: Object as PropType<User>,
      required: true
    }
  },
  emits: ['edit'],
  methods: {
    handleEdit() {
      this.$emit('edit', this.user)
    }
  }
})
</script>
```
{% endraw %}

### **Composition API with TypeScript**

{% raw %}
```vue
<!-- UserList.vue -->
<template>
  <div class="user-list">
    <h2>Users</h2>
    <ul>
      <li v-for="user in users" :key="user.id">
        <UserCard :user="user" @edit="handleEdit" />
      </li>
    </ul>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import UserCard from './UserCard.vue'

interface User {
  id: number
  name: string
  email: string
}

const users = ref<User[]>([])
const loading = ref<boolean>(true)

const fetchUsers = async (): Promise<void> => {
  try {
    loading.value = true
    const response = await fetch('/api/users')
    const data = await response.json()
    users.value = data
  } catch (error) {
    console.error('Failed to fetch users:', error)
  } finally {
    loading.value = false
  }
}

const handleEdit = (user: User): void => {
  console.log('Edit user:', user)
}

onMounted(() => {
  fetchUsers()
})
</script>
```
{% endraw %}

### **Generic Components**

{% raw %}
```vue
<!-- GenericList.vue -->
<template>
  <div class="generic-list">
    <h3>{{ title }}</h3>
    <ul>
      <li v-for="item in items" :key="keyExtractor(item)">
        <slot :item="item" :index="items.indexOf(item)">
          {{ item }}
        </slot>
      </li>
    </ul>
  </div>
</template>

<script setup lang="ts" generic="T">
import { PropType } from 'vue'

interface Props<T> {
  items: T[]
  title: string
  keyExtractor: (item: T) => string | number
}

defineProps<Props<T>>()
</script>
```
{% endraw %}

---

## üé£ **Composition API**

### **Reactive and Ref**

{% raw %}
```typescript
// Composition API with TypeScript
import { ref, reactive, computed, watch } from 'vue'

interface User {
  id: number
  name: string
  email: string
  age: number
}

// Using ref for primitive values
const count = ref<number>(0)
const message = ref<string>('Hello')
const user = ref<User | null>(null)

// Using reactive for objects
const state = reactive<{
  users: User[]
  loading: boolean
  error: string | null
}>({
  users: [],
  loading: false,
  error: null
})

// Computed properties
const userCount = computed<number>(() => state.users.length)
const adultUsers = computed<User[]>(() => 
  state.users.filter(user => user.age >= 18)
)

// Watchers
watch(count, (newValue, oldValue) => {
  console.log(`Count changed from ${oldValue} to ${newValue}`)
})

watch(
  () => state.users,
  (newUsers) => {
    console.log('Users updated:', newUsers)
  },
  { deep: true }
)
```
{% endraw %}

### **Custom Composables**

{% raw %}
```typescript
// useApi.ts
import { ref, Ref } from 'vue'

interface UseApiResult<T> {
  data: Ref<T | null>
  loading: Ref<boolean>
  error: Ref<string | null>
  execute: () => Promise<void>
}

export function useApi<T>(url: string): UseApiResult<T> {
  const data = ref<T | null>(null)
  const loading = ref<boolean>(false)
  const error = ref<string | null>(null)

  const execute = async (): Promise<void> => {
    try {
      loading.value = true
      error.value = null
      const response = await fetch(url)
      const result = await response.json()
      data.value = result
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'An error occurred'
    } finally {
      loading.value = false
    }
  }

  return { data, loading, error, execute }
}

// Usage in component
<script setup lang="ts">
import { useApi } from '@/composables/useApi'

interface User {
  id: number
  name: string
  email: string
}

const { data: users, loading, error, execute } = useApi<User[]>('/api/users')

// Execute on mount
onMounted(() => {
  execute()
})
</script>
```
{% endraw %}

### **Lifecycle Hooks**

{% raw %}
```typescript
// Lifecycle hooks with TypeScript
import { 
  onMounted, 
  onUnmounted, 
  onUpdated, 
  onBeforeMount,
  onBeforeUnmount 
} from 'vue'

export default defineComponent({
  setup() {
    const timer = ref<number | null>(null)

    onBeforeMount(() => {
      console.log('Component will be mounted')
    })

    onMounted(() => {
      console.log('Component is mounted')
      timer.value = setInterval(() => {
        console.log('Timer tick')
      }, 1000)
    })

    onUpdated(() => {
      console.log('Component updated')
    })

    onBeforeUnmount(() => {
      console.log('Component will be unmounted')
    })

    onUnmounted(() => {
      console.log('Component is unmounted')
      if (timer.value) {
        clearInterval(timer.value)
      }
    })

    return {}
  }
})
```
{% endraw %}

---

## üìù **Props and Emits**

### **Props Typing**

{% raw %}
```vue
<!-- UserForm.vue -->
<template>
  <form @submit.prevent="handleSubmit">
    <input v-model="form.name" placeholder="Name" />
    <input v-model="form.email" placeholder="Email" />
    <input v-model.number="form.age" type="number" placeholder="Age" />
    <button type="submit">Submit</button>
  </form>
</template>

<script setup lang="ts">
import { reactive } from 'vue'

interface User {
  id: number
  name: string
  email: string
  age: number
}

interface Props {
  initialUser?: User
  disabled?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  initialUser: undefined,
  disabled: false
})

const form = reactive<Omit<User, 'id'>>({
  name: props.initialUser?.name || '',
  email: props.initialUser?.email || '',
  age: props.initialUser?.age || 0
})

const handleSubmit = () => {
  // Handle form submission
}
</script>
```
{% endraw %}

### **Emits Typing**

{% raw %}
```vue
<!-- UserCard.vue -->
<template>
  <div class="user-card">
    <h3>{{ user.name }}</h3>
    <p>{{ user.email }}</p>
    <button @click="handleEdit">Edit</button>
    <button @click="handleDelete">Delete</button>
  </div>
</template>

<script setup lang="ts">
interface User {
  id: number
  name: string
  email: string
}

interface Props {
  user: User
}

interface Emits {
  edit: [user: User]
  delete: [userId: number]
  update: [user: User]
}

const props = defineProps<Props>()
const emit = defineEmits<Emits>()

const handleEdit = () => {
  emit('edit', props.user)
}

const handleDelete = () => {
  emit('delete', props.user.id)
}

const handleUpdate = (updatedUser: User) => {
  emit('update', updatedUser)
}
</script>
```
{% endraw %}

### **Complex Props**

{% raw %}
```vue
<!-- DataTable.vue -->
<template>
  <table>
    <thead>
      <tr>
        <th v-for="column in columns" :key="column.key">
          {{ column.title }}
        </th>
      </tr>
    </thead>
    <tbody>
      <tr v-for="item in data" :key="keyExtractor(item)">
        <td v-for="column in columns" :key="column.key">
          <slot 
            :name="column.key" 
            :item="item" 
            :value="item[column.key]"
          >
            {{ item[column.key] }}
          </slot>
        </td>
      </tr>
    </tbody>
  </table>
</template>

<script setup lang="ts" generic="T">
interface Column<T> {
  key: keyof T
  title: string
  sortable?: boolean
  width?: string
}

interface Props<T> {
  data: T[]
  columns: Column<T>[]
  keyExtractor: (item: T) => string | number
}

defineProps<Props<T>>()
</script>
```
{% endraw %}

---

## üîÑ **Reactive Data**

### **Reactive Objects**

{% raw %}
```typescript
// Reactive objects with TypeScript
import { reactive, toRefs } from 'vue'

interface UserState {
  users: User[]
  loading: boolean
  error: string | null
  selectedUser: User | null
}

const userState = reactive<UserState>({
  users: [],
  loading: false,
  error: null,
  selectedUser: null
})

// Destructure reactive object
const { users, loading, error, selectedUser } = toRefs(userState)

// Update reactive state
const fetchUsers = async () => {
  userState.loading = true
  userState.error = null
  
  try {
    const response = await fetch('/api/users')
    userState.users = await response.json()
  } catch (err) {
    userState.error = err instanceof Error ? err.message : 'An error occurred'
  } finally {
    userState.loading = false
  }
}
```
{% endraw %}

### **Computed Properties**

{% raw %}
```typescript
// Computed properties with TypeScript
import { computed, ref } from 'vue'

const users = ref<User[]>([])
const searchQuery = ref<string>('')
const sortBy = ref<keyof User>('name')
const sortOrder = ref<'asc' | 'desc'>('asc')

// Computed with complex logic
const filteredAndSortedUsers = computed<User[]>(() => {
  let filtered = users.value.filter(user =>
    user.name.toLowerCase().includes(searchQuery.value.toLowerCase()) ||
    user.email.toLowerCase().includes(searchQuery.value.toLowerCase())
  )

  filtered.sort((a, b) => {
    const aValue = a[sortBy.value]
    const bValue = b[sortBy.value]
    
    if (aValue < bValue) return sortOrder.value === 'asc' ? -1 : 1
    if (aValue > bValue) return sortOrder.value === 'asc' ? 1 : -1
    return 0
  })

  return filtered
})

// Computed with getter and setter
const selectedUserIds = ref<number[]>([])

const isAllSelected = computed({
  get: () => users.value.length > 0 && selectedUserIds.value.length === users.value.length,
  set: (value: boolean) => {
    if (value) {
      selectedUserIds.value = users.value.map(user => user.id)
    } else {
      selectedUserIds.value = []
    }
  }
})
```
{% endraw %}

### **Watchers**

{% raw %}
```typescript
// Watchers with TypeScript
import { watch, watchEffect } from 'vue'

// Watch single source
watch(searchQuery, (newQuery, oldQuery) => {
  console.log(`Search query changed from "${oldQuery}" to "${newQuery}"`)
  // Perform search
})

// Watch multiple sources
watch(
  [searchQuery, sortBy, sortOrder],
  ([newQuery, newSortBy, newSortOrder], [oldQuery, oldSortBy, oldSortOrder]) => {
    console.log('Search or sort changed')
    // Perform search and sort
  }
)

// Watch with options
watch(
  () => userState.users,
  (newUsers, oldUsers) => {
    console.log('Users updated:', newUsers.length - oldUsers.length, 'users changed')
  },
  { deep: true, immediate: true }
)

// WatchEffect
watchEffect(() => {
  console.log(`Total users: ${users.value.length}`)
  console.log(`Selected users: ${selectedUserIds.value.length}`)
})
```
{% endraw %}

---

## üöÄ **Advanced Patterns**

### **Provide/Inject**

{% raw %}
```typescript
// Provide/Inject with TypeScript
import { provide, inject, InjectionKey } from 'vue'

interface UserService {
  getUsers: () => Promise<User[]>
  createUser: (user: Omit<User, 'id'>) => Promise<User>
  updateUser: (id: number, user: Partial<User>) => Promise<User>
  deleteUser: (id: number) => Promise<void>
}

const userServiceKey: InjectionKey<UserService> = Symbol('userService')

// Provider
export const provideUserService = (service: UserService) => {
  provide(userServiceKey, service)
}

// Consumer
export const useUserService = (): UserService => {
  const service = inject(userServiceKey)
  if (!service) {
    throw new Error('UserService not provided')
  }
  return service
}

// Usage in parent component
<script setup lang="ts">
import { provideUserService } from '@/services/userService'

const userService = new UserService()
provideUserService(userService)
</script>

// Usage in child component
<script setup lang="ts">
import { useUserService } from '@/services/userService'

const userService = useUserService()
const users = await userService.getUsers()
</script>
```
{% endraw %}

### **Custom Directives**

{% raw %}
```typescript
// Custom directive with TypeScript
import { Directive, DirectiveBinding } from 'vue'

interface VFocusBinding {
  value: boolean
  arg?: string
  modifiers?: {
    lazy?: boolean
  }
}

const vFocus: Directive<HTMLElement, VFocusBinding> = {
  mounted(el, binding) {
    if (binding.value) {
      el.focus()
    }
  },
  updated(el, binding) {
    if (binding.value) {
      el.focus()
    }
  }
}

// Usage
<template>
  <input v-focus="true" />
  <input v-focus:lazy="shouldFocus" />
</template>
```
{% endraw %}

### **Plugin Development**

{% raw %}
```types
// Plugin with TypeScript
import { App, Plugin } from 'vue'

interface PluginOptions {
  apiUrl: string
  timeout: number
}

interface ApiPlugin {
  get: <T>(url: string) => Promise<T>
  post: <T>(url: string, data: any) => Promise<T>
  put: <T>(url: string, data: any) => Promise<T>
  delete: <T>(url: string) => Promise<T>
}

declare module '@vue/runtime-core' {
  interface ComponentCustomProperties {
    $api: ApiPlugin
  }
}

export const apiPlugin: Plugin = {
  install(app: App, options: PluginOptions) {
    const api: ApiPlugin = {
      get: async <T>(url: string): Promise<T> => {
        const response = await fetch(`${options.apiUrl}${url}`)
        return response.json()
      },
      post: async <T>(url: string, data: any): Promise<T> => {
        const response = await fetch(`${options.apiUrl}${url}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        })
        return response.json()
      },
      put: async <T>(url: string, data: any): Promise<T> => {
        const response = await fetch(`${options.apiUrl}${url}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        })
        return response.json()
      },
      delete: async <T>(url: string): Promise<T> => {
        const response = await fetch(`${options.apiUrl}${url}`, {
          method: 'DELETE'
        })
        return response.json()
      }
    }

    app.config.globalProperties.$api = api
  }
}
```
{% endraw %}

---

## ‚úÖ **Best Practices**

### **1. Use Strict Typing**

{% raw %}
```typescript
// ‚úÖ Good: Strict typing
interface User {
  id: number
  name: string
  email: string
}

const users = ref<User[]>([])

// ‚ùå Avoid: Loose typing
const users = ref<any[]>([])
```
{% endraw %}

### **2. Use Composition API**

{% raw %}
```typescript
// ‚úÖ Good: Composition API
<script setup lang="ts">
import { ref, computed } from 'vue'

const count = ref(0)
const doubleCount = computed(() => count.value * 2)
</script>

// ‚ùå Avoid: Options API for complex logic
<script lang="ts">
export default defineComponent({
  data() {
    return { count: 0 }
  },
  computed: {
    doubleCount() {
      return this.count * 2
    }
  }
})
</script>
```
{% endraw %}

### **3. Use Custom Composables**

{% raw %}
```typescript
// ‚úÖ Good: Custom composable
const useCounter = (initialValue: number = 0) => {
  const count = ref(initialValue)
  const increment = () => count.value++
  const decrement = () => count.value--
  return { count, increment, decrement }
}

// ‚ùå Avoid: Duplicating logic
const count1 = ref(0)
const increment1 = () => count1.value++
const count2 = ref(0)
const increment2 = () => count2.value++
```
{% endraw %}

### **4. Use Proper Event Types**

{% raw %}
```typescript
// ‚úÖ Good: Proper event types
const handleClick = (event: MouseEvent) => {
  event.preventDefault()
  // Handle click
}

// ‚ùå Avoid: Generic event types
const handleClick = (event: any) => {
  event.preventDefault()
  // Handle click
}
```
{% endraw %}

---

## ‚ùì **Common Interview Questions**

### **1. How do you set up TypeScript with Vue.js?**

**Answer:**
1. Install TypeScript and Vue TypeScript support
2. Configure tsconfig.json
3. Use `<script setup lang="ts">` for components
4. Define interfaces for props and data

### **2. What's the difference between ref and reactive in Vue 3?**

**Answer:**
- **ref**: For primitive values, returns a reactive reference
- **reactive**: For objects, makes the object reactive

### **3. How do you type props in Vue 3 with TypeScript?**

**Answer:**
{% raw %}
```typescript
interface Props {
  title: string
  count: number
}

defineProps<Props>()
```
{% endraw %}

### **4. How do you create custom composables with TypeScript?**

**Answer:**
{% raw %}
```typescript
const useApi = <T>(url: string) => {
  const data = ref<T | null>(null)
  const loading = ref(false)
  // ... logic
  return { data, loading }
}
```
{% endraw %}

### **5. How do you handle emits in Vue 3 with TypeScript?**

**Answer:**
{% raw %}
```typescript
interface Emits {
  update: [value: string]
  delete: [id: number]
}

const emit = defineEmits<Emits>()
```
{% endraw %}

---

## üß≠ Navigation

<div class="navigation">
  <a href="02-TypeScript-React.md" class="nav-button">‚Üê Previous: TypeScript with React</a>
  <a href="04-TypeScript-Angular.md" class="nav-button">Next: TypeScript with Angular ‚Üí</a>
</div>

*Last updated: December 2025*
